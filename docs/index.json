[{"categories":["blog"],"content":"blog","date":"2021-06-21","objectID":"/07-speak-record/","tags":["blog"],"title":"相关语录记录","uri":"/07-speak-record/"},{"categories":["blog"],"content":" 了解自己是最困难的事，人想要过得开心，就需要认识清楚自己到底想要啥。 – 曾阿牛 八小时内某生存，八小时以外谋发展。 努力 * 机遇 * 杠杆 = 人生 – 程序员小浩 ","date":"2021-06-21","objectID":"/07-speak-record/:0:0","tags":["blog"],"title":"相关语录记录","uri":"/07-speak-record/"},{"categories":["go"],"content":"本篇主要介绍 Go 语言常使用的channel，以及基本的使用方法.","date":"2021-05-30","objectID":"/26-go-channel-1/","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"1 简述 channel 是Go语言的核心数据结构和 goroutine 之间的通信方式，channel 是支撑Go语言高性能并发编程模型的重要数据结构。 channel 也是最常用的数据结构之一，用好和弄懂Go的 channel 才可以写出更好的代码。 这边也会通过几个篇幅描述一个 channel 的具体使用和相关的原理以及常用的方法。 ","date":"2021-05-30","objectID":"/26-go-channel-1/:1:0","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"2 channel的发展 CSP 的应用 ","date":"2021-05-30","objectID":"/26-go-channel-1/:2:0","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"3 channel和sync Don’t communicate by sharing memory, share memory by communicating. 摘要 不要通过共享内存来通信，而要通过通信来共享内存。 ","date":"2021-05-30","objectID":"/26-go-channel-1/:3:0","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"3.1 sync 的解决方案 ","date":"2021-05-30","objectID":"/26-go-channel-1/:3:1","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"3.2 channel 的解决方案 ","date":"2021-05-30","objectID":"/26-go-channel-1/:3:2","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"3.3 sync和channel的选择 尽管 Go 的设计者极力推荐使用 CSP 的方式来解决并发问题，但是 CSP 只是解决并发安全问题的其中一种途径，在某些场景，还是要具体问题具体分析。 课程中给出的建议如下： 课程建议 共享资源的并发访问使用传统并发原语； 复杂的任务编排和消息传递使用 Channel； 消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond； 简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以； 需要和 Select 语句结合，使用 Channel； 需要和超时配合时，使用 Channel 和 Context。 ","date":"2021-05-30","objectID":"/26-go-channel-1/:3:3","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"4 channel的基本用法 ","date":"2021-05-30","objectID":"/26-go-channel-1/:4:0","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"4.1 channel的基本类型 chan // 既可以发送数据，又可以接收数据的 channel chan\u003c- // 只能接收数据的 channel \u003c-chan // 只能发送数据的 channel ","date":"2021-05-30","objectID":"/26-go-channel-1/:4:1","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"4.2 channel的初始化方式 ch := make(chan struct{}, 10) 未初始化的channel零值为 nil ,10是channel的容量，也可以不指定容量，即容量为零。如果不指定channel长度的情况，一般称为无缓冲的channel。 uber channel通常size应为1或是无缓冲的。默认情况下，channel是无缓冲的，其size为零。任何其他尺寸都必须经过严格的审查。考虑如何确定大小，是什么阻止了channel在负载下被填满并阻止写入，以及发生这种情况时发生了什么。 ","date":"2021-05-30","objectID":"/26-go-channel-1/:4:2","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"4.3 channel的基本用法 1. 发送数据 ch := make(chan struct{}) ch \u003c- struct{}{} 2. 接收数据 ch := make(chan struct{}) \u003c-ch channel中接收数据的时候，还可以接收两个值: val, ok := \u003c-ch if !ok { fmt.Println(\"close\") } _ = val ok 是一个bool值，表示是否成功的从 channel 中接收到了数据。如果 ok 是 false， ch 已经被 close, 且 ch 中没有缓存数据，那么 val 就是零值。 所以如果 val 是零值，有可能是接收到了零值，也有可能是空的且被close的channel产生的零值。 3. 其他操作 close cap len select forange ","date":"2021-05-30","objectID":"/26-go-channel-1/:4:3","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"5 使用channel常见的错误 panic、goroutine 泄露 ","date":"2021-05-30","objectID":"/26-go-channel-1/:5:0","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"5.1 panic错误 close 为 nil 的 channel send 已经 close 的 channel close 已经 close 的 channel ","date":"2021-05-30","objectID":"/26-go-channel-1/:5:1","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"5.2 goroutine泄露 channel的阻塞导致goroutine的泄露 ","date":"2021-05-30","objectID":"/26-go-channel-1/:5:2","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["go"],"content":"6 总结 简单的介绍了 channel 的基本使用方法。 Hugo 的运行环境 –\u003e -- 关于 CDN 配置的技巧 –\u003e -- --","date":"2021-05-30","objectID":"/26-go-channel-1/:6:0","tags":["go"],"title":"【Go】channel的基本使用方法","uri":"/26-go-channel-1/"},{"categories":["开发工具"],"content":"fzf配置及常用快捷键.","date":"2021-05-30","objectID":"/09-grep-use/","tags":["开发工具"],"title":"【grep】基本使用总结","uri":"/09-grep-use/"},{"categories":["开发工具"],"content":"1 简介 grep 是开发检索日志字段常用的方式，具体的使用方式也没有进行总结，目前最常用的使用方式 grep -rin {检索的内容}，之前也没有明确的去学习 -rin 是什么意思。今天来一起学习一下 grep 的详细使用吧。 ","date":"2021-05-30","objectID":"/09-grep-use/:1:0","tags":["开发工具"],"title":"【grep】基本使用总结","uri":"/09-grep-use/"},{"categories":["开发工具"],"content":"2 安装 grep 是linux自带的软件，其他相关的检索工具还包括 ag ack 等，有兴趣的可以一起学习一下。 ","date":"2021-05-30","objectID":"/09-grep-use/:2:0","tags":["开发工具"],"title":"【grep】基本使用总结","uri":"/09-grep-use/"},{"categories":["开发工具"],"content":"3 基本使用 Linux grep 命令用于查找文件里符合条件的字符串。 grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。 -a 或 –text : 不要忽略二进制的数据。 -A\u003c显示行数\u003e 或 –after-context=\u003c显示行数\u003e : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B\u003c显示行数\u003e 或 –before-context=\u003c显示行数\u003e : 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c 或 –count : 计算符合样式的列数。 -C\u003c显示行数\u003e 或 –context=\u003c显示行数\u003e或-\u003c显示行数\u003e : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d \u003c动作\u003e 或 –directories=\u003c动作\u003e : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e\u003c范本样式\u003e 或 –regexp=\u003c范本样式\u003e : 指定字符串做为查找文件内容的样式。 -E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。 -f\u003c规则文件\u003e 或 –file=\u003c规则文件\u003e : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F 或 –fixed-regexp : 将样式视为固定字符串的列表。 -G 或 –basic-regexp : 将样式视为普通的表示法来使用。 -h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。 -i 或 –ignore-case : 忽略字符大小写的差别。 -l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。 -L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。 -n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。 -o 或 –only-matching : 只显示匹配PATTERN 部分。 -q 或 –quiet或–silent : 不显示任何信息。 -r 或 –recursive : 此参数的效果和指定\"-d recurse\"参数相同。 -s 或 –no-messages : 不显示错误信息。 -v 或 –invert-match : 显示不包含匹配文本的所有行。 -V 或 –version : 显示版本信息。 -w 或 –word-regexp : 只显示全字符合的列。 -x –line-regexp : 只显示全列符合的列。 -y : 此参数的效果和指定\"-i\"参数相同。 ","date":"2021-05-30","objectID":"/09-grep-use/:3:0","tags":["开发工具"],"title":"【grep】基本使用总结","uri":"/09-grep-use/"},{"categories":["开发工具"],"content":"4 常用方法 grep -rin \"cond\" zgrep \"cond\" ","date":"2021-05-30","objectID":"/09-grep-use/:4:0","tags":["开发工具"],"title":"【grep】基本使用总结","uri":"/09-grep-use/"},{"categories":["开发工具"],"content":"5 总结 简单的总结了一下grep的使用方法。 ","date":"2021-05-30","objectID":"/09-grep-use/:5:0","tags":["开发工具"],"title":"【grep】基本使用总结","uri":"/09-grep-use/"},{"categories":["开发工具"],"content":"fzf配置及常用快捷键.","date":"2021-05-17","objectID":"/08-fzf-use/","tags":["开发工具"],"title":"【fzf】模糊查找神器-fzf","uri":"/08-fzf-use/"},{"categories":["开发工具"],"content":"1 简介 日常开发目前还是主要使用windows为主，window上查询文件的神奇有everything就够了，但是linux上，有些时候需要经常的输入重复的命令，如果命名很长的话，重复输出极其的麻烦。 后面发现的fzf这个神奇，可以模糊查询命令历史记录，这个也是我用fzf使用最多场景的地方。fzf还可以和vim集成也是很好用，这篇文章主要介绍一下 fzf 的安装和配置相关的，以及相关快捷键。 ","date":"2021-05-17","objectID":"/08-fzf-use/:1:0","tags":["开发工具"],"title":"【fzf】模糊查找神器-fzf","uri":"/08-fzf-use/"},{"categories":["开发工具"],"content":"2 Install # fzf install git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf ~/.fzf/install # ag install # centos7 yum -y install the_silver_searcher # ubuntu sudo apt-get install silversearcher-ag ","date":"2021-05-17","objectID":"/08-fzf-use/:2:0","tags":["开发工具"],"title":"【fzf】模糊查找神器-fzf","uri":"/08-fzf-use/"},{"categories":["开发工具"],"content":"3 zsh-config # vim ~/.zshrc export FZF_DEFAULT_COMMAND='ag --hidden --ignore .git -l -g \"\"' export FZF_DEFAULT_OPTS=\"--height 40% --layout=reverse --preview '(highlight -O ansi {} || cat {}) 2\u003e /dev/null | head -500'\" # source ~/.zshrc ","date":"2021-05-17","objectID":"/08-fzf-use/:3:0","tags":["开发工具"],"title":"【fzf】模糊查找神器-fzf","uri":"/08-fzf-use/"},{"categories":["开发工具"],"content":"4 常用快捷键 CTRL-T 查找目录下条目 CTRL-R 查找历史命令 在输出交换窗口里 Ctrl-J/Ctrl-K/Ctrl-N/Ctrlk-N可以用来将光标上下移动 Enter键用来选中条目， Ctrl-C/Ctrl-G/Esc用来退出 在多选模式下（-m), TAB和Shift-TAB用来多选 Mouse: 上下滚动， 选中， 双击； Shift-click或shift-scoll用于多选模式 ","date":"2021-05-17","objectID":"/08-fzf-use/:4:0","tags":["开发工具"],"title":"【fzf】模糊查找神器-fzf","uri":"/08-fzf-use/"},{"categories":["开发工具"],"content":"5 搜索语法 fzf默认会以“extened-search\"模式启动， 这种模式下你可以输入多个以空格分隔的搜索关键词， 如^music .mp3$, sbtrkt !fire. ","date":"2021-05-17","objectID":"/08-fzf-use/:5:0","tags":["开发工具"],"title":"【fzf】模糊查找神器-fzf","uri":"/08-fzf-use/"},{"categories":["开发工具"],"content":"6 总结 zsh + oh-my-zsh + fzf 快去优化你的linux环境吧, 如果有使用vim的也可以去研究一下怎么集成到vim中。 ","date":"2021-05-17","objectID":"/08-fzf-use/:6:0","tags":["开发工具"],"title":"【fzf】模糊查找神器-fzf","uri":"/08-fzf-use/"},{"categories":["go"],"content":"简单说明了Go语言中，数组和切片的区别，以及一些简单的切片使用技巧和注意点.","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"Golang 语言中数组和切片的区别是什么？ ","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"1 介绍 Golang语言中，使用数组的情况并不多。切片使用更加广泛。 切片的底层存储也是基于数组。 ","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"2 数组和切换的区别 数组的零值是元素类型的零值，切片的零值是 nil。 数组是固定长度，切片是可变长度。 数组是值类型，切片是引用类型。 数组中元素超越边界会引发错误，切片中元素超越边界会自动扩容。 数组是值类型，切片是引用类型。 在 Golang 语言中传递数组属于值拷贝，如果数组的元素个数比较多或者元素类型的大小比较大时，直接将数组作为函数参数会造成性能损耗，可能会有读者想到使用数组指针作为函数参数，这样是可以避免性能损耗，但是在 Golang 语言中，更流行使用切片，关于这块内容，阅读完 Part 04 的切片数据结构，会有更加深入的理解。 ","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"3 切片的扩容规则 切片扩容实际是创建一个新的底层数组，把原切片的元素和新元素一起拷贝到新切片的底层数组中，原切片的底层数组将会被垃圾回收。 注意：切片的容量可以根据元素的个数的增多自动扩容，但是不会根据元素的个数的减少自动缩容。 在原切片长度小于 1024 时，新切片的容量会按照原切片的 2 倍扩容，否则，新切片的容量会按照原切片的 1.25 倍扩容。 ","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"4 切片数据结构 在 Golang 语言中，切片实际是一个结构体，源码如下所示： // /usr/local/go/src/runtime/slice.go type slice struct { array unsafe.Pointer len int cap int } 阅读源码，我们可以发现先，slice 结构体包含 3 个字段： 字段 说明 array 指向底层数组 len 切片的长度 cap 切片的容量 在 Golang 语言运行时中，一个切片类型的变量实际上就是 runtime.slice 结构体的实例，其中 arrray 字段是指针类型，指向切片的底层数组，len 是切片的长度，cap 是切片的容量，当使用 make 函数创建切片时，如果不指定 cap 参数的值，cap 的值就等于 len 的值。 ","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:4:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"5 切片编程技巧 明白底层的原理的情况，为了降低或避免内存分配和拷贝的代价，我们通常会为新创建的切片指定 cap 参数的值，比如： s := make([]T, 0, cap) 但是，这种使用方式的前提是，我们可以预估切片的元素个数。 ","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:5:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"6 for range 遍历切片 通过使用 for range 遍历切片，每次遍历操作实际上是对遍历元素的拷贝。而使用 for 遍历切片，每次遍历是通过索引访问切片元素，性能会远高于通过 for range 遍历。 因此想要优化使用 for range 遍历切片的性能，可以使用空白标识符 _ 省略每次遍历返回的切片元素，改为使用切片索引取访问切片的元素。 普通方式: func main () { s := make([]int, 0, 10000) for k, v := range s { fmt.Println(s, v) } } 优化方式: func main () { s := make([]int, 0, 10000) for k, _ := range s { fmt.Println(k, s[k]) } } ","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:6:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"7 总结 简单的说明了切换和数组的区别，介绍了关闭切换扩容的规则，数组结构和使用技巧等。 注意 –\u003e -- Hugo 的运行环境 –\u003e -- 关于 CDN 配置的技巧 –\u003e -- --","date":"2021-04-06","objectID":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/:7:0","tags":["go"],"title":"【Go】Golang 语言中数组和切片的区别是什么？","uri":"/25-%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["开发工具"],"content":"个人的ideavim配置及相关说明.","date":"2021-04-03","objectID":"/07-ideavimrc-cfg/","tags":["开发工具"],"title":"【ideavim】GoLand的vim环境插件配置","uri":"/07-ideavimrc-cfg/"},{"categories":["开发工具"],"content":"1 简介 Goland的vim插件也集成了各种各种各样的功能使用。基本上可以满足个人的使用需求，避免使用vim学习成本太高的问题，现在很多编译器自己的功能集成，核心自定义的功能确实会比vim的好用。但是又舍弃不了vim操作上的便捷性，所以有了这边ideavim配置的说明，也是对自己ideavim配置的一个记录 ","date":"2021-04-03","objectID":"/07-ideavimrc-cfg/:1:0","tags":["开发工具"],"title":"【ideavim】GoLand的vim环境插件配置","uri":"/07-ideavimrc-cfg/"},{"categories":["开发工具"],"content":"2 配置 ","date":"2021-04-03","objectID":"/07-ideavimrc-cfg/:2:0","tags":["开发工具"],"title":"【ideavim】GoLand的vim环境插件配置","uri":"/07-ideavimrc-cfg/"},{"categories":["开发工具"],"content":"2.1 配置记录 先直接来一份个人配置. \" 设置 \u003cLEADER\u003e as \u003cSPACE\u003e let mapleader=\" \" \" 去除VI一致性,必须要添加 \" 不要使用vi的键盘模式，而是vim自己的 set nocompatible \" 打开行号和相关行号的配置 set relativenumber set number \" 快速上下左右跳转 noremap H 5k noremap L 5j noremap W 5w noremap B 5b \" K 区域选着，window环境个人还是屏蔽所有ctrl的vim按键 noremap K \u003cC-v\u003e \" kj 设置为esc inoremap kj \u003cESC\u003e \" 设置搜索相关 set hlsearch exec \"nohlsearch\" set incsearch set ignorecase set smartcase \" 搜索跳转 noremap = nzz noremap - Nzz noremap n nzz noremap N Nzz noremap \u003cLEADER\u003e\u003cCR\u003e :nohlsearch\u003cCR\u003e \" go config \" 到go的方法名 noremap gm \u003cS-i\u003e\u003cESC\u003ef)2l \" 到go的函数名 noremap gf \u003cS-i\u003e\u003cESC\u003e5l \" 查找括号 noremap f9 f( \" 查找括号 noremap f0 f) \" 拷贝到系统的剪切板 noremap \u003cS-y\u003e \\\"+y \" === \" === easymotion \" === \" easyMotion 模拟，额外依赖插件：AceJump,IdeaVim-EasyMotion set easymotion let g:EasyMotion_do_mapping = 0 \" Disable default mappings \" `s{char}{char}{label}` \" Need one more keystroke, but on average, it may be more comfortable. nmap \u003cLeader\u003es \u003cPlug\u003e(easymotion-s2) \" Turn on case-insensitive feature let g:EasyMotion_smartcase = 1 \" JK motions: Line motions map \u003cLeader\u003ej \u003cPlug\u003e(easymotion-j) map \u003cLeader\u003ek \u003cPlug\u003e(easymotion-k) \"\"\" Map leader to space --------------------- \" let mapleader=\" \" \"\"\" Plugins -------------------------------- \" set surround \" set multiple-cursors \" set commentary \" set argtextobj \" set easymotion \" set textobj-entire \" set ReplaceWithRegister \"\"\" Plugin settings ------------------------- \" let g:argtextobj_pairs=\"[:],(:),\u003c:\u003e\" \"\"\" Common settings ------------------------- set showmode \" 行数留余 set so=3 \" set incsearch \" set nu \"\"\" Idea specific settings ------------------ \" set ideajoin \" set ideastatusicon=gray \" set idearefactormode=keep \"\"\" Mappings -------------------------------- \" map \u003cleader\u003ef \u003cPlug\u003e(easymotion-s) \" map \u003cleader\u003ee \u003cPlug\u003e(easymotion-f) map \u003cleader\u003ed \u003cAction\u003e(Debug) map \u003cleader\u003er \u003cAction\u003e(Run) \" map \u003cleader\u003er \u003cAction\u003e(RenameElement) map \u003cleader\u003ec \u003cAction\u003e(Stop) map \u003cleader\u003ez \u003cAction\u003e(ToggleDistractionFreeMode) map \u003cleader\u003ep \u003cAction\u003e(TogglePresentationMode) map \u003cleader\u003ef \u003cAction\u003e(SelectInProjectView) \" map \u003cleader\u003ea \u003cAction\u003e(Annotate) \" map \u003cleader\u003eh \u003cAction\u003e(Vcs.ShowTabbedFileHistory) \" map \u003cS-Space\u003e \u003cAction\u003e(GotoNextError) map \u003cleader\u003eb \u003cAction\u003e(ToggleLineBreakpoint) map \u003cleader\u003eo \u003cAction\u003e(FileStructurePopup) \" === \" === IdeaVimExtension \" === \" 为IdeaVim插件增加自动切换为英文输入法的功能, \" idea 需要安装 IdeaVimExtension plugin set keep-english-in-normal \" set keep-english-in-normal-and-restore-in-insert 回到insert模式时恢复输入法 \" set nokeep-english-in-normal-and-restore-in-insert 保留输入法自动切换功能，但是回到insert模式不恢复输入法 \" set nokeep-english-in-normal 关闭输入法自动切换功能 ","date":"2021-04-03","objectID":"/07-ideavimrc-cfg/:2:1","tags":["开发工具"],"title":"【ideavim】GoLand的vim环境插件配置","uri":"/07-ideavimrc-cfg/"},{"categories":["开发工具"],"content":"2.2 配置说明 参考2.1中的注释。 ","date":"2021-04-03","objectID":"/07-ideavimrc-cfg/:2:2","tags":["开发工具"],"title":"【ideavim】GoLand的vim环境插件配置","uri":"/07-ideavimrc-cfg/"},{"categories":["开发工具"],"content":"3 总结 vim需要一定的学习成本，但是学习好的话，可以大大的提高效率。 磨刀不误砍柴工 工欲善其事必先利其器 ","date":"2021-04-03","objectID":"/07-ideavimrc-cfg/:3:0","tags":["开发工具"],"title":"【ideavim】GoLand的vim环境插件配置","uri":"/07-ideavimrc-cfg/"},{"categories":["开发工具"],"content":"访问github是程序员经常要用的，查询相关优秀的开源库学习，必备的网址，那么说说怎么加速访问","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"1 简介 ​ 访问github是程序员经常要用的，查询相关优秀的开源库学习，必备的网址，为什么要加速访问，相信大家都清楚，那么今天说说怎么加速访问。 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:1:0","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2 常用的加速方法 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:0","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.1 GitHub 镜像访问 提供两个最常用的镜像地址: https://hub.fastgit.org https://github.com.cnpmjs.org 镜像网站，网站的内容跟 GitHub 是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:1","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.2 GitHub 文件加速 利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN. https://gh.api.99988866.xyz https://g.ioiox.com 以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub(https://hunsh.net/archives/23/) 文件加速自行部署。 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:2","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.3 Github 加速下载 只需要复制当前 GitHub 地址粘贴到输入框中就可以代理加速下载！ http://toolwa.com/github/ ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:3","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.4 加速你的 Github https://github.zhlh6.cn 输入 Github 仓库地址，使用生成的地址进行 git ssh 等操作 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:4","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.5 谷歌浏览器 GitHub 加速插件(推荐) Github加速 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:5","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.6 GitHub raw 加速 ​ GitHub raw 域名并非 github.com 而是 raw.githubusercontent.com，上方的 GitHub 加速如果不能加速这个域名，那么可以使用 Static CDN 提供的反代服务。 ​ 将 raw.githubusercontent.com 替换为 raw.staticdn.net 即可加速。 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:6","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.7 GitHub + Jsdelivr jsdelivr 唯一美中不足的就是它不能获取 exe 文件以及 Release 处附加的 exe 和 dmg 文件。 也就是说如果 exe 文件是附加在 Release 处但是没有在 code 里面的话是无法获取的。所以只能当作静态文件 cdn 用途，而不能作为 Release 加速下载的用途。 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:7","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.8 通过 Gitee 中转 fork 仓库下载 网上有很多相关的教程，这里简要的说明下操作。 访问 gitee 网站：https://gitee.com/ 并登录，在顶部选择“从 GitHub/GitLab 导入仓库” 如下： ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:8","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"2.9 通过修改 HOSTS 文件进行加速 手动把cdn和ip地址绑定。 第一步：获取 github 的 global.ssl.fastly 地址访问：http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo 获取cdn和ip域名： 得到：199.232.69.194 https://github.global.ssl.fastly.net 第二步：获取github.com地址 访问：https://github.com.ipaddress.com/#ipinfo 获取cdn和ip： 得到：140.82.114.4 http://github.com 第三步：修改 host 文件映射上面查找到的 IP windows系统： 1、修改C:\\Windows\\System32\\drivers\\etc\\hosts文件的权限，指定可写入：右击-\u003ehosts-\u003e属性-\u003e安全-\u003e编辑-\u003e点击Users-\u003e在Users的权限“写入”后面打勾。如下： 图片 然后点击确定。 2、右击-\u003ehosts-\u003e打开方式-\u003e选定记事本（或者你喜欢的编辑器）-\u003e在末尾处添加以下内容： 199.232.69.194 github.global.ssl.fastly.net 140.82.114.4 github.com ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:2:9","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["开发工具"],"content":"3 总结 基本介绍了常用的Github加速的方式，希望你有需要使用的情况，可以使用上。 ","date":"2021-03-10","objectID":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/:3:0","tags":["开发工具"],"title":"【开发工具】Github访问加速的常用方式和技巧","uri":"/06-github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"},{"categories":["go"],"content":"使用Go语言实现，json格式打印的日志文件，格式化打印工具","date":"2021-02-24","objectID":"/24-go-json-log-format/","tags":["go"],"title":"【Go】实现json日志格式化观察程序","uri":"/24-go-json-log-format/"},{"categories":["go"],"content":"1 简述 Log目前微服务日志量大，存储数据多，切分散，常常需要使用es的收集日志。 传统的日志格式打印的数据不利于es的分析使用，日志存储es上Json格式的日志是非常用必要的， 方便数据分析和检索，那么问题来了，Json格式的数据有利于机器的分析和检索， 那么人眼观察变的异常的困难，还好是Json格式的日志，所以可以对日志进行格式化处理。 ","date":"2021-02-24","objectID":"/24-go-json-log-format/:1:0","tags":["go"],"title":"【Go】实现json日志格式化观察程序","uri":"/24-go-json-log-format/"},{"categories":["go"],"content":"2 源码 package main import ( \"bufio\" \"bytes\" \"encoding/json\" \"flag\" \"fmt\" \"os\" \"strings\" ) var fileString = flag.String(\"f\", \"./input.log\", \"Input Your cli string\") func main() { flag.Parse() if strings.Contains(*fileString, \"./\") { fileName := *fileString *fileString = fileName[2:] } fRead, err := os.Open(*fileString) if err != nil { fmt.Printf(\"failed open the file %s\", *fileString) return } defer func() { _ = fRead.Close() }() outFileString := \"output-\" + *fileString if isExist(outFileString) { os.Remove(outFileString) } // 创建输出文件 output.txt 用于存放输出结果 fWrite, err2 := os.Create(outFileString) if err2 != nil { fmt.Println(err) panic(err2) } defer func() { _ = fWrite.Close() }() // create a scanner fs := bufio.NewScanner(fRead) // scan file // https://golang.org/pkg/bufio/#Scanner.Scan for fs.Scan() { strLine := fs.Bytes() formatStr, _ := handleStr(strLine) _, _ = fWrite.Write(formatStr) } } func handleStr(b []byte) ([]byte, error) { var out bytes.Buffer err := json.Indent(\u0026out, b, \"\", \"\\t\") if err != nil { return nil, err } jsonIndent := out.Bytes() time, level, err := getTimeAndLevel(b) timeLevelInfo := fmt.Sprintf(\"%s:%6s\\t\\t\", time, level) var formatStr = make([]byte, 0, len(jsonIndent)) formatStr = append(formatStr, timeLevelInfo...) for _, ch := range jsonIndent { formatStr = append(formatStr, ch) if ch == '\\n' { formatStr = append(formatStr, timeLevelInfo...) } } formatStr = append(formatStr, '\\n') return formatStr, err } func getTimeAndLevel(b []byte) (string, string, error) { type data struct { Time string `json:\"time\"` Level string `json:\"level\"` } var d data if err := json.Unmarshal(b, \u0026d); err != nil { return \"\", \"\", err } return d.Time, d.Level, nil } func isExist(path string) bool { _, err := os.Stat(path) if err != nil { if os.IsExist(err) { return true } if os.IsNotExist(err) { return false } return false } return true } ","date":"2021-02-24","objectID":"/24-go-json-log-format/:2:0","tags":["go"],"title":"【Go】实现json日志格式化观察程序","uri":"/24-go-json-log-format/"},{"categories":["go"],"content":"3 格式化对比 ","date":"2021-02-24","objectID":"/24-go-json-log-format/:3:0","tags":["go"],"title":"【Go】实现json日志格式化观察程序","uri":"/24-go-json-log-format/"},{"categories":["go"],"content":"3.1 格式化前数据 GOROOT=C:\\Go #gosetup GOPATH=D:\\GoPath #gosetup C:\\Go\\bin\\go.exe build -o D:\\Users\\yl1754\\AppData\\Local\\Temp\\___703go_build_mars_cmd.exe mars/cmd #gosetup D:\\Users\\yl1754\\AppData\\Local\\Temp\\___703go_build_mars_cmd.exe #gosetup 2021-02-24T19:50:35.523+0800 INFO cmd/mars.go:18 mars on init ... {\"level\":\"INFO\",\"time\":\"2021-02-24T19:50:35.543+0800\",\"caller\":\"cmd/init.go:20\",\"msg\":\"env:dev, region:cn-shanghai ip:10.71.4.28\"} {\"level\":\"INFO\",\"time\":\"2021-02-24T19:50:35.543+0800\",\"caller\":\"cmd/mars.go:30\",\"msg\":\"mars on start ...\"} [GEE-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GEE_MODE=release - using code: gee.SetMode(gee.ReleaseMode) [GEE-debug] GET /meeting-port-manager/api/v1/meetings/:meetingID/test --\u003e mars/internal/service/consumerservice/router.(*router).initRoutes.func1 (3 handlers) [GEE-debug] POST /meeting-port-manager/api/v1/meetings/:meetingID/body --\u003e mars/internal/service/consumerservice/router.(*router).initRoutes.func2 (3 handlers) [GEE-debug] POST /meeting-port-manager/api/v1/meetings/:meetingID/reader --\u003e mars/internal/service/consumerservice/router.(*router).initRoutes.func3 (3 handlers) {\"level\":\"INFO\",\"time\":\"2021-02-24T19:50:35.543+0800\",\"caller\":\"consumer/consumer.go:52\",\"msg\":\"yrmq server instance mars_1981391775\"} {\"level\":\"DEBUG\",\"time\":\"2021-02-24T19:50:35.543+0800\",\"caller\":\"consumer/consumer.go:43\",\"msg\":\"YRMQ start success. {Addr:10.120.26.62:9076 AccessKey: SecretKey:}\"} {\"level\":\"INFO\",\"time\":\"2021-02-24T19:50:35.754+0800\",\"caller\":\"http/client.go:210\",\"msg\":\"http client\",\"http.request.method\":\"POST\",\"url.path\":\"/api/v1/token\",\"url.query\":{},\"destination.address\":\"10.120.26.62:9979\",\"X-Y-Request-Id\":\"da421472-c67a-46b6-8ce7-971c3c94ea8e\",\"http.request.body.content\":\"{\\\"grant_type\\\":\\\"client_credentials\\\"}\",\"http.response.status_code\":200,\"http.response.body.content\":\"{\\\"access_token\\\":\\\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJkZXMiOjAsImFrcCI6MCwiY3BjIjpbInVzZXItbWFuYWdlciIsInlnYSIsInlwdXNoIiwicmVndWxhdG9yIl0sImFraWQiOiJkNmE0YTAzNDVhNzY0MDMwOGY5MTMxMDBlMTE3ZjRkZiIsImFrcyI6MCwiYWsiOiI0Y2M4MmVmYTg5NjE0ZDVmOGMyMDQ4YjE5OWNkNTAxZiIsImRlbCI6MCwiYWt0IjowLCJleHAiOjE2MTQxNjkyMDksImp0aSI6IjZlZjFjZjAwNTE2MzQyNDlhYjU3NGM1OTcxYzNjMDllIiwiZGlkIjoiOTgzZjhmODQxMjU0NDYwMGE2MGI1M2JkNWQ1MTI2Y2EifQ.F51cNGkvcfWW-07TTwMqHujTWUPGsA--cdTNjqguXJURMdZsLkFAuXH_Pfm5sNO3H0ougW7-1X2LHanKRIIRxdWqmtbyU5TEZ-DKmszfJgw5W7lCTMobdZsu6jJsYHyDJ-NzvA7zgNO2ZrJamgtUtGFR4ukibCrh9ywb6IQqmu2IHtStbIVRs71AlLrTQ28EVpE0tmOzbQmojEpAieC6hIj19GEB72hug70ArLrXPC_cV3t3FNGyWb-kYi6XOT-yoeMDUWDJpj4J0AiN0F03mCYSqyyj6D43-qcLFaXgUG7uDHNVavVC_9CzVFlrtEEMP89Afa_D2vphiqgJS5y6Ow\\\",\\\"token_type\\\":\\\"bearer\\\",\\\"expires_in\\\":1799}\",\"cost\":209} {\"level\":\"INFO\",\"time\":\"2021-02-24T19:51:58.167+0800\",\"caller\":\"middleware/access_log.go:26\",\"msg\":\"http server\",\"source.address\":\"\",\"http.request.method\":\"POST\",\"url.original\":\"/meeting-port-manager/api/v1/meetings/123123123/reader\",\"user_agent.original\":\"EnvDefaultAppID\",\"X-Y-Request-Id\":\"ded1916d-a5b5-4e2f-9170-7c5bef72a1d8\",\"X-Y-Session-Id\":\"\",\"http.request.body.content\":\"{\\\"displayName\\\":\\\"test\\\"}\",\"http.response.status_code\":200,\"http.response.body.content\":\"e3Rlc3R9\",\"cost\":0} {\"level\":\"INFO\",\"time\":\"2021-02-24T19:51:58.168+0800\",\"caller\":\"yconn/yconn.go:116\",\"msg\":\"new conn pool addr 10.120.26.62:9445\"} {\"level\":\"INFO\",\"time\":\"2021-02-24T19:52:45.800+0800\",\"caller\":\"middleware/access_log.go:26\",\"msg\":\"http server\",\"source.address\":\"\",\"http.request.method\":\"POST\",\"url.original\":\"/meeting-port-manager/api/v1/meetings/123123123/reader\",\"user_agent.original\":\"EnvDefaultAppID\",\"X-Y-Request-Id\":\"17e7760c-ff8c-48d8-a692-4f9f932084d6\",\"X-Y-Session-Id\":\"\",\"http.request.body.content\":\"{\\\"displayName\\\":\\\"test\\\"}\",\"http.response.status_code\":200,\"http.response.body.content\":\"e3Rlc3R9\",\"cost\":0} {\"level\":\"INFO\",\"time\":\"2021-02-24T19:52:50.720+0800\",\"caller\":\"middleware/access_log.go:26\",\"msg\":\"http server\",\"source.address\":\"\",\"http.request.method\":\"POST\",\"url.orig","date":"2021-02-24","objectID":"/24-go-json-log-format/:3:1","tags":["go"],"title":"【Go】实现json日志格式化观察程序","uri":"/24-go-json-log-format/"},{"categories":["go"],"content":"3.2 格式化后数据 2021-02-24T19:50:35.543+0800: INFO { 2021-02-24T19:50:35.543+0800: INFO \"level\": \"INFO\", 2021-02-24T19:50:35.543+0800: INFO \"time\": \"2021-02-24T19:50:35.543+0800\", 2021-02-24T19:50:35.543+0800: INFO \"caller\": \"cmd/init.go:20\", 2021-02-24T19:50:35.543+0800: INFO \"msg\": \"env:dev, region:cn-shanghai ip:10.71.4.28\" 2021-02-24T19:50:35.543+0800: INFO } 2021-02-24T19:50:35.543+0800: INFO { 2021-02-24T19:50:35.543+0800: INFO \"level\": \"INFO\", 2021-02-24T19:50:35.543+0800: INFO \"time\": \"2021-02-24T19:50:35.543+0800\", 2021-02-24T19:50:35.543+0800: INFO \"caller\": \"cmd/mars.go:30\", 2021-02-24T19:50:35.543+0800: INFO \"msg\": \"mars on start ...\" 2021-02-24T19:50:35.543+0800: INFO } 2021-02-24T19:50:35.543+0800: INFO { 2021-02-24T19:50:35.543+0800: INFO \"level\": \"INFO\", 2021-02-24T19:50:35.543+0800: INFO \"time\": \"2021-02-24T19:50:35.543+0800\", 2021-02-24T19:50:35.543+0800: INFO \"caller\": \"consumer/consumer.go:52\", 2021-02-24T19:50:35.543+0800: INFO \"msg\": \"yrmq server instance mars_1981391775\" 2021-02-24T19:50:35.543+0800: INFO } 2021-02-24T19:50:35.543+0800: DEBUG { 2021-02-24T19:50:35.543+0800: DEBUG \"level\": \"DEBUG\", 2021-02-24T19:50:35.543+0800: DEBUG \"time\": \"2021-02-24T19:50:35.543+0800\", 2021-02-24T19:50:35.543+0800: DEBUG \"caller\": \"consumer/consumer.go:43\", 2021-02-24T19:50:35.543+0800: DEBUG \"msg\": \"YRMQ start success. {Addr:10.120.26.62:9076 AccessKey: SecretKey:}\" 2021-02-24T19:50:35.543+0800: DEBUG } 2021-02-24T19:50:35.754+0800: INFO { 2021-02-24T19:50:35.754+0800: INFO \"level\": \"INFO\", 2021-02-24T19:50:35.754+0800: INFO \"time\": \"2021-02-24T19:50:35.754+0800\", 2021-02-24T19:50:35.754+0800: INFO \"caller\": \"http/client.go:210\", 2021-02-24T19:50:35.754+0800: INFO \"msg\": \"http client\", 2021-02-24T19:50:35.754+0800: INFO \"http.request.method\": \"POST\", 2021-02-24T19:50:35.754+0800: INFO \"url.path\": \"/api/v1/token\", 2021-02-24T19:50:35.754+0800: INFO \"url.query\": {}, 2021-02-24T19:50:35.754+0800: INFO \"destination.address\": \"10.120.26.62:9979\", 2021-02-24T19:50:35.754+0800: INFO \"X-Y-Request-Id\": \"da421472-c67a-46b6-8ce7-971c3c94ea8e\", 2021-02-24T19:50:35.754+0800: INFO \"http.request.body.content\": \"{\\\"grant_type\\\":\\\"client_credentials\\\"}\", 2021-02-24T19:50:35.754+0800: INFO \"http.response.status_code\": 200, 2021-02-24T19:50:35.754+0800: INFO \"http.response.body.content\": \"{\\\"access_token\\\":\\\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJkZXMiOjAsImFrcCI6MCwiY3BjIjpbInVzZXItbWFuYWdlciIsInlnYSIsInlwdXNoIiwicmVndWxhdG9yIl0sImFraWQiOiJkNmE0YTAzNDVhNzY0MDMwOGY5MTMxMDBlMTE3ZjRkZiIsImFrcyI6MCwiYWsiOiI0Y2M4MmVmYTg5NjE0ZDVmOGMyMDQ4YjE5OWNkNTAxZiIsImRlbCI6MCwiYWt0IjowLCJleHAiOjE2MTQxNjkyMDksImp0aSI6IjZlZjFjZjAwNTE2MzQyNDlhYjU3NGM1OTcxYzNjMDllIiwiZGlkIjoiOTgzZjhmODQxMjU0NDYwMGE2MGI1M2JkNWQ1MTI2Y2EifQ.F51cNGkvcfWW-07TTwMqHujTWUPGsA--cdTNjqguXJURMdZsLkFAuXH_Pfm5sNO3H0ougW7-1X2LHanKRIIRxdWqmtbyU5TEZ-DKmszfJgw5W7lCTMobdZsu6jJsYHyDJ-NzvA7zgNO2ZrJamgtUtGFR4ukibCrh9ywb6IQqmu2IHtStbIVRs71AlLrTQ28EVpE0tmOzbQmojEpAieC6hIj19GEB72hug70ArLrXPC_cV3t3FNGyWb-kYi6XOT-yoeMDUWDJpj4J0AiN0F03mCYSqyyj6D43-qcLFaXgUG7uDHNVavVC_9CzVFlrtEEMP89Afa_D2vphiqgJS5y6Ow\\\",\\\"token_type\\\":\\\"bearer\\\",\\\"expires_in\\\":1799}\", 2021-02-24T19:50:35.754+0800: INFO \"cost\": 209 2021-02-24T19:50:35.754+0800: INFO } 2021-02-24T19:51:58.167+0800: INFO { 2021-02-24T19:51:58.167+0800: INFO \"level\": \"INFO\", 2021-02-24T19:51:58.167+0800: INFO \"time\": \"2021-02-24T19:51:58.167+0800\", 2021-02-24T19:51:58.167+0800: INFO \"caller\": \"middleware/access_log.go:26\", 2021-02-24T19:51:58.167+0800: INFO \"msg\": \"http server\", 2021-02-24T19:51:58.167+0800: INFO \"source.address\": \"\", 2021-02-24T19:51:58.167+0800: INFO \"http.request.method\": \"POST\", 2021-02-24T19:51:58.167+0800: INFO \"url.original\": \"/meeting-port-manager/api/v1/meetings/123123123/reader\", 2021-02-24T19:51:58.167+0800: INFO \"user_agent.original\": \"EnvDefaultAppID\", 2021-02-24T19:51:58.167+0800: INFO \"X-Y-Request-Id\": \"ded1916d-a5b5-4e2f-9170-7c5bef72a1d8\", 2021-02-24T19:51:58.167+0800: INFO \"X-Y-Session-Id\": \"\", 2021-02-24T19:51:58.167+0800: ","date":"2021-02-24","objectID":"/24-go-json-log-format/:3:2","tags":["go"],"title":"【Go】实现json日志格式化观察程序","uri":"/24-go-json-log-format/"},{"categories":["go"],"content":"4 总结 具体代码非常的简单，写的比较随便。本篇文章主要用于保存源码，也不多做什么介绍了 对比发现，格式化后的日志配合notepad++可以大大的提高检索的效率。 最后，提示大家，学习了Go语言也去看看你身边有什么可以编写的小工具吧。 ","date":"2021-02-24","objectID":"/24-go-json-log-format/:4:0","tags":["go"],"title":"【Go】实现json日志格式化观察程序","uri":"/24-go-json-log-format/"},{"categories":["编程"],"content":"之前学习有听说过自顶向下的编程方法，没有具体的去实践，详解自顶向下的编程方法，定义和实践。","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"1 简述 自顶向下的程序设计方法指的是首先从主控程序开始，然后按接口关系逐次分割每个功能为更小的功能模块，直到最低层模块设计完成为止。自顶向下是一种有序的逐步分层分解和求精的程序设计方法。其特点是层次清楚，编写方便，调试容易。 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:1:0","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"2 自顶向下 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:2:0","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"2.1 思考过程 明确整个类或者主函数最终要的任务是做什么，然后进一步细分需要几步，将步骤抽成函数，此时不需要函数的具体实现，只需要将函数命名成具体的实现相关即可。 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:2:1","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"2.2 与面条式写法对比 说说面条式写法缺点： 方法代码很长，很难维护。 测试不友好，非常不利于单元测试。 编写过程思路不清晰，容易不小心引入bug。 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:2:2","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"2.3 优点 编码过程中思路更清晰，可以暂时屏蔽繁琐的细节，关注任务的全貌，使得编写的代码结构清晰，不容易引入bug。 代码阅读更容易，方便后期维护。 代码的编写过程是自顶向下逐层细化的，可以在编程的早期就形成一个可以被单元测试的函数 解决了很多人习惯的在编码完成后，再去进行所谓的重构优化的难题。面条式的代码一旦形成，想要拆分确实是难上加难。 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:2:3","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"2.4 延伸 思想除了编程过程中有用之外，还可以运用到日常生活中很多其他的地方 比如说我写这篇博客的时候，就是先完成目录的结构，然后再去完成具体的细节部分。 制定个人计划 程序测试测试用例的编写 我们人类天生就擅长这种思考方式，希望这篇文章你能学习到一点点。 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:2:4","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"2.5 编程建议 目前我主要使用的是c、Golang、C sharp三门语言。 编程语言的建议，都可以使用自顶向下的编程思想。 建议主干函数放到编程文件的较前面，实现的细节放在后文。目前可能也是c语言需要使用前定义，不过也可以使用提前声明去解决这个问题。 学习研究研究报纸是怎么定义文章结构的，是否在编程语言的格式上可以参采取相应的一些措施。 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:2:5","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["编程"],"content":"3 总结 有良好的编程思想非常的重要，可以让你写出更好的代码结构，可读性更强，出问题的概率更低的代码。 ","date":"2021-02-08","objectID":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/:3:0","tags":["编程"],"title":"【编程思想】核心编程方法之一——自顶向下的编程方法","uri":"/13-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"categories":["go"],"content":"明白go channel的哪些操作会引发panic，你就可以去避免它","date":"2021-02-02","objectID":"/23-go-channel-panic/","tags":["go"],"title":"【Go】channel的哪些操作会引发panic?","uri":"/23-go-channel-panic/"},{"categories":["go"],"content":"1 简述 Go channel明白哪些情况channel会发生panic是去避免发生的最好的方式。如果不清楚panic的时间的话，就算你中午不出事，早晚也会出事的。还是那句话，基础的知识点继续掌握它。 ","date":"2021-02-02","objectID":"/23-go-channel-panic/:1:0","tags":["go"],"title":"【Go】channel的哪些操作会引发panic?","uri":"/23-go-channel-panic/"},{"categories":["go"],"content":"2 Channel Panic 1. 关闭一个 nil 值 channel 会引发 panic package main func main() { var ch chan struct{} close(ch) } panic: close of nil channel goroutine 1 [running]: main.main() /Users/liuzhiwei/code/go/mgo/Gee/test/main/main.go:5 +0x2a 2. 关闭一个已经关闭的channel会引发panic package main func main() { ch := make(chan struct{}) close(ch) close(ch) } panic: close of closed channel goroutine 1 [running]: main.main() /Users/liuzhiwei/code/go/mgo/Gee/test/main/main.go:6 +0x57 3. 向一个已经关闭的channel发送数据 package main func main() { ch := make(chan struct{}) close(ch) ch \u003c- struct{}{} } panic: send on closed channel goroutine 1 [running]: main.main() /Users/liuzhiwei/code/go/mgo/Gee/test/main/main.go:6 +0x65 ","date":"2021-02-02","objectID":"/23-go-channel-panic/:2:0","tags":["go"],"title":"【Go】channel的哪些操作会引发panic?","uri":"/23-go-channel-panic/"},{"categories":["go"],"content":"3 总结 如果你对某块代码没有安全感，相信我，就算它中午不出事，早晚也得出事。 ","date":"2021-02-02","objectID":"/23-go-channel-panic/:3:0","tags":["go"],"title":"【Go】channel的哪些操作会引发panic?","uri":"/23-go-channel-panic/"},{"categories":["go"],"content":"go的非常轻易的实现高并发，goroutine也是异步处理数据最常用的手段，参数传递你搞懂了吗？.","date":"2021-02-02","objectID":"/22-go-question/","tags":["go"],"title":"【Go】一道简单的goroutine问题，参数传递你有没有搞懂","uri":"/22-go-question/"},{"categories":["go"],"content":"1 简述 Goroutine 是并发编程必须掌握的东西，之前在go语言中文网看到的一道题目，尽然有%65的Gopher 没有回答正确，今天就来说说这个题目。 ","date":"2021-02-02","objectID":"/22-go-question/:1:0","tags":["go"],"title":"【Go】一道简单的goroutine问题，参数传递你有没有搞懂","uri":"/22-go-question/"},{"categories":["go"],"content":"2 题目 package main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan int) go fmt.Println(\u003c-ch1) ch1 \u003c- 5 time.Sleep(1 * time.Second) } 你认为输出的结果是什么呢? 5 编译不通过 运行时死锁 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /Users/liuzhiwei/code/go/mgo/test/main.go:10 +0x65 ","date":"2021-02-02","objectID":"/22-go-question/:2:0","tags":["go"],"title":"【Go】一道简单的goroutine问题，参数传递你有没有搞懂","uri":"/22-go-question/"},{"categories":["go"],"content":"3 看看这题 package main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan int) go func() { fmt.Println(\u003c-ch1) }() ch1 \u003c- 5 time.Sleep(1 * time.Second) } 答案你认为是什么呢？ ","date":"2021-02-02","objectID":"/22-go-question/:3:0","tags":["go"],"title":"【Go】一道简单的goroutine问题，参数传递你有没有搞懂","uri":"/22-go-question/"},{"categories":["go"],"content":"4 总结 在 Go 语言规范中，关于 go 语句[1]有这么一句描述： GoStmt = \"go\" Expression . The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements[2]. The function value and parameters are evaluated as usual[3] in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. 这里说明，go 语句后面的函数调用，其参数会先求值，这和普通的函数调用求值一样。在规范中调用部分[4]是这样描述的： Given an expression f of function type F, f(a1, a2, … an) calls f with arguments a1, a2, … an. Except for one special case, arguments must be single-valued expressions assignable[5] to the parameter types of F and are evaluated before the function is called. 大意思是说，函数调用之前，实参就被求值好了。 因此这道题目 go fmt.Println(\u003c-ch1) 语句中的 \u003c-ch1 是在 main goroutine 中求值的。这相当于一个无缓冲的 chan，发送和接收操作都在一个 goroutine 中（main goroutine）进行，因此造成死锁。 更进一步，大家可以通过汇编看看上面两种方式的不同。 此外，defer 语句也要注意。比如下面的做法是不对的： defer recover() 而应该使用这样的方式： defer func() { recover() }() 简单的问题，原理一定需要掌握。 ","date":"2021-02-02","objectID":"/22-go-question/:4:0","tags":["go"],"title":"【Go】一道简单的goroutine问题，参数传递你有没有搞懂","uri":"/22-go-question/"},{"categories":["go"],"content":"通过分析一个简单的切换的题目，看你是否有真的理解Go语言，只有值传递的方.","date":"2021-01-19","objectID":"/21-go-question/","tags":["go"],"title":"【Go】今天简单的看一个Go切片的题目，看下你有没有做错","uri":"/21-go-question/"},{"categories":["go"],"content":"1 简述 Go Slice也是开发过程中频繁使用的关键字，你有真正理解Slice的原理吗？具体原理的话，这边目前先不做分析了，网上的资料很多，可能后续有时间的话这边也会总结一下。今天就来看一个简简单单的Go语言题目吧。 ","date":"2021-01-19","objectID":"/21-go-question/:1:0","tags":["go"],"title":"【Go】今天简单的看一个Go切片的题目，看下你有没有做错","uri":"/21-go-question/"},{"categories":["go"],"content":"2 题目 package main import \"fmt\" func testFunc1(data []int) { data[0] = 1000 } func testFunc2(data []int) { data = append(data, 2000) } func main() { a := make([]int, 0, 10) a = append(a, 1) testFunc1(a) fmt.Println(a) testFunc2(a) fmt.Println(a) } 你认为输出的结果是什么呢? 输出结果信息： $ go run main [1000] [1000] 输出是否和你想象的一样？你是否有这样的疑问 2000 去哪里了？切片不是引用传递吗？ 不懂原理的可能会猜想： 是否切换append扩容了，data = append(data, 2000)输入的data的地址和返回的data的地址不同。 没有data返回不出来？ 具体原因分析： 首先需要理解切片的底层结构，使用 len cap unsafe指针三个元素构成的。容量，长度和指向底层数组的指针,切片可以随时进行扩展 理解切换什么时候进行数据扩容 知道go语言只有值传递没有引用传递 具体我也不说透了，我相信你可以理解的。 ","date":"2021-01-19","objectID":"/21-go-question/:2:0","tags":["go"],"title":"【Go】今天简单的看一个Go切片的题目，看下你有没有做错","uri":"/21-go-question/"},{"categories":["go"],"content":"3 总结 ​ 通过代码，简单的说明了Go语言的几点特性。希望你以后不会遇到类似的问题。如果最后你还是没有理解可以给我留言。我希望遇到问题的话，自己可以先写代码学习验证。 ","date":"2021-01-19","objectID":"/21-go-question/:3:0","tags":["go"],"title":"【Go】今天简单的看一个Go切片的题目，看下你有没有做错","uri":"/21-go-question/"},{"categories":["go"],"content":"for range的简单使用的介绍及其语法糖的原理分析.","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["go"],"content":"1 简述 for range 是Go语言 提供的一种迭代遍历的手段，通常我们使用可以操作的类型有数组、切片、Map、Channel等，实际使用频率非常的高。所以它的原理的话，我们必须要掌握清楚。 ","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/:1:0","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["go"],"content":"2 For Range ","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/:2:0","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["go"],"content":"2.1 for range 使用 2.1.1 数组 package main import \"fmt\" func main() { array := [3]int{1, 2, 3} for i, v := range array { fmt.Printf(\"array[%d]=%d\\n\", i, v) } } // out array[0]=1 array[1]=2 array[2]=3 2.1.2 切片 package main import \"fmt\" func main() { slice := []int{1, 2, 3} for i, v := range slice { fmt.Printf(\"slice[%d]=%d\\n\", i, v) } } // out slice[0]=1 slice[1]=2 slice[2]=3 2.1.3 Map package main import \"fmt\" func main() { dataMap := map[int]int{ 1: 1, 2: 2, } for i, v := range dataMap { fmt.Printf(\"dataMap[%d]=%d\\n\", i, v) } } // out dataMap[1]=1 dataMap[2]=2 2.1.4 Channel // TODO ","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/:2:1","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["go"],"content":"2.2 for range 奇妙的问题 TODO 遍历append for..range的坑 ","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/:2:2","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["go"],"content":"2.3 for range 语法糖 原理代码: // Arrange to do a loop appropriate for the type. We will produce // for INIT ; COND ; POST { // ITER_INIT // INDEX = INDEX_TEMP // VALUE = VALUE_TEMP // If there is a value // original statements // } 可见range实际上是一个C风格的循环结构。range支持数组、数组指针、切片、map和channel类型，对于不同类型有些细节上的差异。 2.3.1 数组 // len_temp := len(range) // range_temp := range // for index_temp = 0; index_temp \u003c len_temp; index_temp++ { // value_temp = range_temp[index_temp] // index = index_temp // value = value_temp // original body //} 2.3.2 切片 // The loop we generate: // for_temp := range // len_temp := len(for_temp) // for index_temp = 0; index_temp \u003c len_temp; index_temp++ { // value_temp = for_temp[index_temp] // index = index_temp // value = value_temp // original body // } 2.3.3 Map // The loop we generate: // var hiter map_iteration_struct // for mapiterinit(type, range, \u0026hiter); hiter.key != nil; mapiternext(\u0026hiter) { // index_temp = *hiter.key // value_temp = *hiter.val // index = index_temp // value = value_temp // original body // } 2.3.4 Channel // The loop we generate: // for { // index_temp, ok_temp = \u003c-range // if !ok_temp { // break // } // index = index_temp // original body // } ","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/:2:3","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["go"],"content":"2.4 一些for range其他的问题 for…range遍历过程中可以delete在map里面的数据吗？ 遍历的过程中，可以参数map的数据。 for…range遍历map的时候，是否需要加锁处理？ 建议所有map的情况都进行加锁处理，除非版本只有并发读的情况，没有出现并发写，或者并发读写的情况。 ","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/:2:4","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["go"],"content":"总结 map应该使我们必须掌握的遍历语法糖，避免出现使用for…range出问题的坑。很多坑自己出现可能只是对for...range的原理不够了解。明白其原理的情况，才能更加正确的使用它。 map ","date":"2021-01-17","objectID":"/20-go-range-%E5%88%86%E6%9E%90/:3:0","tags":["go"],"title":"【Go】for range 高频次使用，你懂它的原理吗？","uri":"/20-go-range-%E5%88%86%E6%9E%90/"},{"categories":["开发工具"],"content":"使用的vimrc配置保存，有需要的可以参考","date":"2021-01-17","objectID":"/12-vimrc-save/","tags":["开发工具"],"title":"【vim】使用的vimrc配置保存，有需要的可以参考","uri":"/12-vimrc-save/"},{"categories":["开发工具"],"content":"1 简述 ​ Vim 号称编辑器之神，唯快不破，可扩展，插件遍天下。学习曲线虽然陡峭，但是学成之后，基本上就成肌肉记忆了，写程序双手不离键盘，上下翻飞，可谓快意编程。 ​ 写过程序的人都知道，编程的时候双手大部分时间都放在键盘上，或编码、或插入、或移动、或定位、或查找，这种连续操作的时间和频率远远大于阅读、翻页、设置字体、摆弄样式等文案工作，而二者往往产生很多停顿和间隙，而编程时的停顿是非常影响编程效率的，所以 Vim 的设计理念就是通过模式的转换、命令的组合和数以万计的插件，保证程序员在编程的过程中，双手尽可能保留在键盘中央的区域，并且，不需要鼠标。 ","date":"2021-01-17","objectID":"/12-vimrc-save/:1:0","tags":["开发工具"],"title":"【vim】使用的vimrc配置保存，有需要的可以参考","uri":"/12-vimrc-save/"},{"categories":["开发工具"],"content":"2 开始 ","date":"2021-01-17","objectID":"/12-vimrc-save/:2:0","tags":["开发工具"],"title":"【vim】使用的vimrc配置保存，有需要的可以参考","uri":"/12-vimrc-save/"},{"categories":["开发工具"],"content":"2.1 Vim的版本 使用Vim目前推荐的版本是vim8.0 ","date":"2021-01-17","objectID":"/12-vimrc-save/:2:1","tags":["开发工具"],"title":"【vim】使用的vimrc配置保存，有需要的可以参考","uri":"/12-vimrc-save/"},{"categories":["开发工具"],"content":"2.2 vimrc的配置 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" PlugList \" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Specify a directory for plugins \" - For Neovim: '~/.config/nvim/plugged' \" - Avoid using standard Vim directory names like 'plugin' call plug#begin('~/.config/nvim/plugged') \" Make sure you use single quotes \" \" go Plug 'fatih/vim-go' Plug 'Blackrush/vim-gocode' \" 美化 Plug 'flazz/vim-colorschemes' Plug 'bling/vim-airline' Plug 'vim-airline/vim-airline-themes' Plug 'mhinz/vim-startify' \" 目录插件 Plug 'scrooloose/nerdtree' \" markdown插件 Plug 'dhruvasagar/vim-table-mode' Plug 'godlygeek/tabular' Plug 'plasticboy/vim-markdown' call plug#end() \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" plugin settings \" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Compile function \" map r :call CompileRunGcc()\u003cCR\u003e \" func! CompileRunGcc() \" exec \"w\" \" if \u0026filetype == 'c' \" exec \"!g++ % -o %\u003c\" \" exec \"!time ./%\u003c\" \" elseif \u0026filetype == 'cpp' \" exec \"!g++ % -o %\u003c\" \" exec \"!time ./%\u003c\" \" elseif \u0026filetype == 'java' \" exec \"!javac %\" \" exec \"!time java %\u003c\" \" elseif \u0026filetype == 'sh' \" :!time bash % \" elseif \u0026filetype == 'python' \" silent! exec \"!clear\" \" exec \"!time python3 %\" \" elseif \u0026filetype == 'html' \" exec \"!firefox % \u0026\" \" elseif \u0026filetype == 'markdown' \" exec \"MarkdownPreview\" \" elseif \u0026filetype == 'vimwiki' \" exec \"MarkdownPreview\" \" endif \" endfunc \" vim-markdown禁用折叠 let g:vim_markdown_folding_disabled = 1 \" markdown-preview.nvim let g:mkdp_auto_start = 0 let g:mkdp_auto_close = 1 let g:mkdp_refresh_slow = 0 let g:mkdp_command_for_global = 0 let g:mkdp_open_to_the_world = 0 let g:mkdp_open_ip = '' let g:mkdp_browser = '' let g:mkdp_echo_preview_url = 0 let g:mkdp_browserfunc = '' let g:mkdp_preview_options = { \\ 'mkit': {}, \\ 'katex': {}, \\ 'uml': {}, \\ 'maid': {}, \\ 'disable_sync_scroll': 0, \\ 'sync_scroll_type': 'middle', \\ 'hide_yaml_meta': 1, \\ 'sequence_diagrams': {}, \\ 'flowchart_diagrams': {}, \\ 'content_editable': v:false, \\ 'disable_filename': 0 \\ } let g:mkdp_markdown_css = '' let g:mkdp_highlight_css = '' let g:mkdp_port = '' let g:mkdp_page_title = '「${name}」' let g:mkdp_filetypes = ['markdown'] \" 去除VI一致性,必须要添加 \" 不要使用vi的键盘模式，而是vim自己的 \" Set \u003cLEADER\u003e as \u003cSPACE\u003e set nocompatible let mapleader=\" \" filetype on filetype indent on filetype plugin on filetype plugin indent on set mouse=a set encoding=utf-8 \" set clipboard=unnamed \" 设置行号显示方式 set number \" 设置相对行号显示方式 set relativenumber set ruler set cursorline set wrap set showcmd set wildmenu set hlsearch exec \"nohlsearch\" set incsearch set ignorecase set smartcase syntax enable syntax on \" 设置Tab长度为4空格 set tabstop=4 \" 设置自动缩进长度为4空格 set shiftwidth=4 \" 自动缩进,这个导致从外面拷贝多行以空格开头的内容时,会有多的缩进,先不设置 \" set autoindent \" 不要用空格代替制表符 set noexpandtab \" 输入tab制表符时，自动替换成空格 \" set expandtab set softtabstop=4 set list set listchars=tab:▸\\ ,trail:▫ set scrolloff=5 \" mac模式下才使用. set backspace=2 \" 设置历史记录 set history=1024 \" 大写s保存 map S :w\u003cCR\u003e map Q :q\u003cCR\u003e \" split the screens to up (horizontal), down (horizontal), left (vertical), right (vertical) map zk :set nosplitbelow\u003cCR\u003e:vsplit\u003cCR\u003e map zj :set splitbelow\u003cCR\u003e:vsplit\u003cCR\u003e map zl :set nosplitright\u003cCR\u003e:vsplit\u003cCR\u003e map zh :set splitright\u003cCR\u003e:vsplit\u003cCR\u003e map tu :tabe\u003cCR\u003e map th :-tabnext\u003cCR\u003e map tl :+tabnext\u003cCR\u003e map tt :NERDTreeToggle\u003cCR\u003e map \u003cLEADER\u003ek \u003cC-w\u003ek map \u003cLEADER\u003ej \u003cC-w\u003ej map \u003cLEADER\u003eh \u003cC-w\u003eh map \u003cLEADER\u003el \u003cC-w\u003el \" map W :wq\u003cCR\u003e imap \u003cF6\u003e \u003cC-x\u003e\u003cC-o\u003e noremap n nzz noremap N Nzz noremap \u003cLEADER\u003e\u003cCR\u003e :nohlsearch\u003cCR\u003e noremap H 5k noremap L 5j noremap K \u003cC-v\u003e \" 突出显示当前列 \" set cursorcolumn \"等同于 set cuc \" markdown config. \"autocmd Filetype markdown map \u003cleader\u003ew yiWi[\u003cesc\u003eEa](\u003cesc\u003epa) autocmd Filetype markdown inoremap ,f \u003cEsc\u003e/\u003c++\u003e\u003cCR\u003e:nohlsearch\u003cCR\u003ec4l autocmd Filetype markdown inoremap ,n ---\u003cEnter\u003e\u003cEnter\u003e autocmd Filetype markdown inoremap ,b **** \u003c++\u003e\u003cEsc\u003eF*hi autocmd Filetype markdown inoremap ,s ~~~~ \u003c++\u003e\u003cEsc\u003eF~hi autocmd ","date":"2021-01-17","objectID":"/12-vimrc-save/:2:2","tags":["开发工具"],"title":"【vim】使用的vimrc配置保存，有需要的可以参考","uri":"/12-vimrc-save/"},{"categories":["开发工具"],"content":"2.3 最新配置 \" __ ____ __ _ ___ _____ __ __ ____ ____ \"| \\/ \\ \\ / / | \\ | \\ \\ / /_ _| \\/ | _ \\ / ___| \"| |\\/| |\\ V / | \\| |\\ \\ / / | || |\\/| | |_) | | \"| | | | | | | |\\ | \\ V / | || | | | _ \u003c| |___ \"|_| |_| |_| |_| \\_| \\_/ |___|_| |_|_| \\_\\\\____| \" Author: @coolliuzw \" === \" === Auto load for first time uses \" === if empty(glob('~/.config/nvim/autoload/plug.vim')) silent !curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim autocmd VimEnter * PlugInstall --sync | source $MYVIMRC endif \" === \" === Create a _machine_specific.vim file to adjust machine specific stuff, like python interpreter location \" === \" let has_machine_specific_file = 1 \" if empty(glob('~/.config/nvim/_machine_specific.vim')) \" let has_machine_specific_file = 0 \" silent! exec \"!cp ~/.config/nvim/default_configs/_machine_specific_default.vim ~/.config/nvim/_machine_specific.vim\" \" endif \" source /root/.config/nvim/_machine_specific.vim \" === \" === Editor behavior \" === set exrc set secure set number set relativenumber set cursorline set hidden set noexpandtab set tabstop=2 set shiftwidth=2 set softtabstop=2 set autoindent set list set listchars=tab:\\|\\ ,trail:▫ set scrolloff=4 set ttimeoutlen=0 set notimeout set viewoptions=cursor,folds,slash,unix set wrap set tw=0 set indentexpr= set foldmethod=indent set foldlevel=99 set foldenable set formatoptions-=tc set splitright set splitbelow set noshowmode set showcmd set wildmenu set ignorecase set smartcase set shortmess+=c set inccommand=split set completeopt=longest,noinsert,menuone,noselect,preview set ttyfast \"should make scrolling faster set lazyredraw \"same as above set visualbell silent !mkdir -p ~/.config/nvim/tmp/backup silent !mkdir -p ~/.config/nvim/tmp/undo \"silent !mkdir -p ~/.config/nvim/tmp/sessions set backupdir=~/.config/nvim/tmp/backup,. set directory=~/.config/nvim/tmp/backup,. if has('persistent_undo') set undofile set undodir=~/.config/nvim/tmp/undo,. endif set colorcolumn=100 set updatetime=100 set virtualedit=block au BufReadPost * if line(\"'\\\"\") \u003e 1 \u0026\u0026 line(\"'\\\"\") \u003c= line(\"$\") | exe \"normal! g'\\\"\" | endif \" === \" === Basic Mappings \" === \" Set \u003cLEADER\u003e as \u003cSPACE\u003e, ; as : let mapleader=\" \" nnoremap \u003cc-[\u003e \u003cc-i\u003e nnoremap \u003cc-]\u003e \u003cc-o\u003e \" Open the vimrc file anytime noremap \u003cLEADER\u003erc :e ~/.config/nvim/init.vim\u003cCR\u003e \" Save \u0026 quit noremap Q :q\u003cCR\u003e noremap \u003cC-q\u003e :qa\u003cCR\u003e noremap ;s :w\u003cCR\u003e \" Wrapped lines goes down/up to next row, rather than next line in file. noremap j gj noremap k gk inoremap kj \u003cESC\u003e \" make Y to copy till the end of the line nnoremap Y y$ \" Copy to system clipboard vnoremap Y \"+y \" Indentation nnoremap \u003c \u003c\u003c nnoremap \u003e \u003e\u003e \" Search noremap \u003cLEADER\u003e\u003cCR\u003e :nohlsearch\u003cCR\u003e \" Adjacent duplicate words noremap \u003cLEADER\u003edw /\\(\\\u003c\\w\\+\\\u003e\\)\\_s*\\1 \" Space to Tab nnoremap \u003cLEADER\u003ett :%s/ /\\t/g vnoremap \u003cLEADER\u003ett :s/ /\\t/g \" Folding noremap \u003csilent\u003e \u003cLEADER\u003eo za \" === \" === Cursor Movement \" === \" Faster in-line navigation noremap W 5w noremap B 5b noremap L 5j noremap H 5k \" === \" === Searching \" === noremap - N noremap = n \" === \" === Window management \" === \" Use \u003cspace\u003e + new arrow keys for moving the cursor around windows noremap \u003cLEADER\u003ew \u003cC-w\u003ew noremap \u003cLEADER\u003ek \u003cC-w\u003ek noremap \u003cLEADER\u003ej \u003cC-w\u003ej noremap \u003cLEADER\u003eh \u003cC-w\u003eh noremap \u003cLEADER\u003el \u003cC-w\u003el noremap qf \u003cC-w\u003eo \" split the screens to up (horizontal), down (horizontal), left (vertical), right (vertical) noremap zj :set nosplitbelow\u003cCR\u003e:split\u003cCR\u003e:set splitbelow\u003cCR\u003e noremap zk :set splitbelow\u003cCR\u003e:split\u003cCR\u003e noremap zl :set nosplitright\u003cCR\u003e:vsplit\u003cCR\u003e:set splitright\u003cCR\u003e noremap zh :set splitright\u003cCR\u003e:vsplit\u003cCR\u003e \" Resize splits with arrow keys noremap \u003cup\u003e :res +5\u003cCR\u003e noremap \u003cdown\u003e :res -5\u003cCR\u003e noremap \u003cleft\u003e :vertical resize-5\u003cCR\u003e noremap \u003cright\u003e :vertical resize+5\u003cCR\u003e \" Press \u003cSPACE\u003e + q to close the window below the current window noremap \u003cLEADER\u003eq \u003cC-w\u003ej:q\u003cCR\u003e \" === \" === Tab management \" === \" Create a new tab with tu noremap tu :tabe\u003cCR\u003e \" Move around tabs with tn and ti nor","date":"2021-01-17","objectID":"/12-vimrc-save/:2:3","tags":["开发工具"],"title":"【vim】使用的vimrc配置保存，有需要的可以参考","uri":"/12-vimrc-save/"},{"categories":["开发工具"],"content":"总结 主要记录，本人vimrc的配置信息，防止vim系统重新安装的情况，配置丢失。有需要的可以参考vimrc的配置信息。 ","date":"2021-01-17","objectID":"/12-vimrc-save/:3:0","tags":["开发工具"],"title":"【vim】使用的vimrc配置保存，有需要的可以参考","uri":"/12-vimrc-save/"},{"categories":["go"],"content":"jd_mtSeckill 的抢购程序使用教程.","date":"2021-01-10","objectID":"/19-go-mt-seckill/","tags":["go"],"title":"【Go】jd_mtSeckill 的抢购程序使用教程","uri":"/19-go-mt-seckill/"},{"categories":["go"],"content":"1 简述 Golang 编写的抢茅台项目 mtSeckill。之前是有一个Python的版本比较火，对Python不太了解加上时间关系没有去整，也没有去看源码。现在有Golang的版本，自己有着几个月的Go编程经验，所以想去学学代码里面并发的思想和精髓。目前初级阶段主要会介绍一下如何使用。 ","date":"2021-01-10","objectID":"/19-go-mt-seckill/:1:0","tags":["go"],"title":"【Go】jd_mtSeckill 的抢购程序使用教程","uri":"/19-go-mt-seckill/"},{"categories":["go"],"content":"2 开始 准备 必须使用Google Chrome浏览器 ","date":"2021-01-10","objectID":"/19-go-mt-seckill/:2:0","tags":["go"],"title":"【Go】jd_mtSeckill 的抢购程序使用教程","uri":"/19-go-mt-seckill/"},{"categories":["go"],"content":"2.1 Go程序开发人员 # 下载代码 $ git clone https://github.com/zqjzqj/mtSecKill.git # 进入代码目录 $ cd mtSecKill # 下载项目相关依赖包，使用go mod的方式 $ go mod tidy # 运行项目 $ go run cmd/main.go 代码会按默认参数进行配置和运行，当然为了使用方便，你也可以编译可运行文件 2.1.1 编译运行程序 # 运行项目 $ go run cmd/main.go # 修改为 # 编译可运行程序 可执行文件的名称「coolliuzw」 $ go build -o coolliuzw_mt cmd/main.go # 运行 $ ./coolliuzw_mt 服务器与本地时间差为: 182 ms 开始执行时间为： 2021-01-11 09:59:59 2.1.2 运行参数说明 其中的参数非常的直观 sku：你抢购的 sku_id，默认是茅台的ID num：抢购数量，茅台最多 2瓶，设置为2 works：开启多少个浏览器窗口抢购，即工作的线程数 time：抢购时间，注意不是日期，而是时间，时间会自动取未来最近一天的时间。 一般直接使用默认的就可以了，以下是测试手动配置，看看有没有变成10个窗口？ $ ./coolliuzw_mt -num=2 -works=10 -time=09:59:58 -sku=100012043978 # 默认运行，建议 $ ./coolliuzw_mt ","date":"2021-01-10","objectID":"/19-go-mt-seckill/:2:1","tags":["go"],"title":"【Go】jd_mtSeckill 的抢购程序使用教程","uri":"/19-go-mt-seckill/"},{"categories":["go"],"content":"2.2 非代码开发人员免配置运行 免配置运行，即使用作者变成好的可运行程序，github的release可以下载到相应平台的版本 2.2.1 mac系统 Mac系统，终端执行该条命令赋予执行权限 chmod +x mtSeckill.mac，然后再执行命令 ./mtSeckill.mac 运行 2.2.2 window系统 下载mtSecKill.win.exe 双击运行即可 ","date":"2021-01-10","objectID":"/19-go-mt-seckill/:2:2","tags":["go"],"title":"【Go】jd_mtSeckill 的抢购程序使用教程","uri":"/19-go-mt-seckill/"},{"categories":["go"],"content":"3 总结 之前对Go实现浏览器控制操作没有什么了解，通过初步学习源码结构，使用chromedp包实现对chrome浏览器的操作控制，后期有时间也打算深度的学习一下源码，说不定，后面6.18和11.11可以抢点其他的东西。 ","date":"2021-01-10","objectID":"/19-go-mt-seckill/:3:0","tags":["go"],"title":"【Go】jd_mtSeckill 的抢购程序使用教程","uri":"/19-go-mt-seckill/"},{"categories":["开发工具"],"content":"为了提高阅读代码的效率使用，使用可以查看代码调用关系图的工具是一个非常好的方式.","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发工具"],"content":"1 简述 阅读Go项目的情况，理清pkg之前的调用和函数之前的调用需要花费一定的时间，那么怎么提高我们阅读 开源 或 新代码的效率呢？ 今天学习的就是使用 go-callvis生成代码函数调用图。 go-callvis是一个开发工具，用于使用交互式视图帮助可视化Go程序的调用图。 该工具的目的是使用调用图中的数据及其与包和类型的关系为开发人员提供Go程序的可视化概述。 这在大型项目中特别有用，在大型项目中代码的复杂性要高得多，或者您只是试图理解其他人的代码。 特征 支持Go module的模式 Focus重点关注程序中的特定程序包 单击程序包以使用交互式查看器快速切换焦点 按包将功能分组和/或将方法按类型分组 将程序包筛选为特定的导入路径前缀 忽略标准库中的函数 省略各种类型的函数调用 ","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/:1:0","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发工具"],"content":"2 开始 ","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/:2:0","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发工具"],"content":"2.1 Go callvis说明 图片说明： Packages / Types Represents Style focused blue color stdlib green color other yellow color Functions / Methods Represents Style exported bold border unexported normal border anonymous dotted border Calls Represents Style internal black color external brown color static solid line dynamic dashed line regular simple arrow concurrent arrow with circle deferred arrow with diamond ","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/:2:1","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发工具"],"content":"2.2 安装 go get -u github.com/ofabry/go-callvis # or git clone https://github.com/ofabry/go-callvis.git cd go-callvis \u0026\u0026 make install // Graphviz 工具安装，这个是可选的，生成的时候添加 -graphviz 参数的时候需要使用到. brew install graphviz ","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/:2:2","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发工具"],"content":"2.3 工具参数说明 命令格式 go-callvis \u003ctarget package\u003e 参数说明 Options Usage of go-callvis: -debug Enable verbose log. 启用详细日志. -file string output filename - omit to use server mode 输出文件名-省略使用服务器模式. -cacheDir string Enable caching to avoid unnecessary re-rendering. 启用缓存以避免不必要的重新渲染. -focus string Focus specific package using name or import path. (default \"main\") 使用名称或导入路径关注特定的程序包。 （默认为“main”）. -format string output file format [svg | png | jpg | ...] (default \"svg\") 输出文件格式[svg | png | jpg | ...]（默认为“ svg”）. -graphviz Use Graphviz's dot program to render images. 使用Graphviz的点程序来渲染图像. -group string Grouping functions by packages and/or types [pkg, type] (separated by comma) (default \"pkg\") 按软件包和/或类型[pkg，type]（用逗号分隔）（默认为“ pkg”） -http string HTTP service address. (default \":7878\") HTTP服务地址。 （默认为“：7878”）. -ignore string Ignore package paths containing given prefixes (separated by comma) 忽略包含给定前缀（用逗号分隔）的包路径. -include string Include package paths with given prefixes (separated by comma) 包含具有给定前缀的软件包路径（以逗号分隔）. -limit string Limit package paths to given prefixes (separated by comma) 将包路径限制为给定的前缀（以逗号分隔）. -minlen uint Minimum edge length (for wider output). (default 2) 最小边长（用于更宽的输出）。 （默认2）. -nodesep float Minimum space between two adjacent nodes in the same rank (for taller output). (default 0.35) 同一等级中两个相邻节点之间的最小间距（用于更高的输出）. -nointer Omit calls to unexported functions. 忽略对未导出函数的调用. -nostd Omit calls to/from packages in standard library. 忽略对标准库中程序包的调用. -skipbrowser Skip opening browser. 跳过打开浏览器. -tags build tags a list of build tags to consider satisfied during the build. For more information about build tags, see the description of build constraints in the documentation for the go/build package 在构建期间要考虑满意的构建标记列表. 有关构建标记的更多信息，请参阅go / build软件包的文档中的构建约束说明. -tests Include test code. 包括测试代码. -version Show version and exit. 显示版本并退出. ","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/:2:3","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发工具"],"content":"2.4 demo样例实操 demo样例实操 eg: go-callvis -focus {pkg_name} -group pkg,type ./ | dot -Tpng -o /tmp/out.png ","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/:2:4","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发工具"],"content":"3 相关问题解决方法 no main packages？ go callvis 只能适用于程序代码，isuue Main package is required for the analysis used, because all the calls in the callgraph tree begins in main (and inits). 使用pkg包的方式 go-callvis -group pkg,type -limit github.com/knq/xo github.com/knq/xo/examples/sqlite3 | dot -Tpng -o /tmp/out.png ","date":"2021-01-09","objectID":"/18-go-callvis%E4%BD%BF%E7%94%A8/:3:0","tags":["开发工具"],"title":"【Go】go-callvis 查看代码调用关系图","uri":"/18-go-callvis%E4%BD%BF%E7%94%A8/"},{"categories":["开发配置"],"content":"Homebrew 是一款自由及开放源代码的软件包管理系统，用以简化 macOS 和 linux 系统上的软件安装过程。它拥有安装、卸载、更新、查看、搜索等很多实用的功能，通过简单的一条指令，就可以实现包管理，十分方便快捷.","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"1 简介 Homebrew 是一款自由及开放源代码的软件包管理系统，用以简化 macOS 和 linux 系统上的软件安装过程。它拥有安装、卸载、更新、查看、搜索等很多实用的功能，通过简单的一条指令，就可以实现包管理，十分方便快捷。 Homebrew 主要有四个部分组成: brew、homebrew-core 、homebrew-bottles、homebrew-cask。 名称 说明 brew Homebrew 源代码仓库 homebrew-core Homebrew 核心软件仓库 homebrew-bottles Homebrew 预编译二进制软件包 homebrew-cask 提供 macOS 应用和大型二进制文件 ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:1:0","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"2 为什么需要切换源 网络慢的情况，很多时候下载不了你需要下载软件。 ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:2:0","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"3 切换国内原 ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:3:0","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"3.1 替换为阿里源 # 查看 brew.git 当前源 $ cd \"$(brew --repo)\" \u0026\u0026 git remote -v origin https://github.com/Homebrew/brew.git (fetch) origin https://github.com/Homebrew/brew.git (push) # 查看 homebrew-core.git 当前源 $ cd \"$(brew --repo homebrew/core)\" \u0026\u0026 git remote -v origin https://github.com/Homebrew/homebrew-core.git (fetch) origin https://github.com/Homebrew/homebrew-core.git (push) # 修改 brew.git 为阿里源 $ git -C \"$(brew --repo)\" remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 修改 homebrew-core.git 为阿里源 $ git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # zsh 替换 brew bintray 镜像 $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' \u003e\u003e ~/.zshrc $ source ~/.zshrc # bash 替换 brew bintray 镜像 $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' \u003e\u003e ~/.bash_profile $ source ~/.bash_profile # 刷新源 $ brew update ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:3:1","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"3.2 替换为清华源 # 替换各个源 $ git -C \"$(brew --repo)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git $ git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git $ git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git # zsh 替换 brew bintray 镜像 $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' \u003e\u003e ~/.zshrc $ source ~/.zshrc # bash 替换 brew bintray 镜像 $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' \u003e\u003e ~/.bash_profile $ source ~/.bash_profile # 刷新源 $ brew update ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:3:2","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"3.3 替换为中科大源 # 替换各个源 $ git -C \"$(brew --repo)\" remote set-url origin https://mirrors.ustc.edu.cn/brew.git $ git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git $ git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git # zsh 替换 brew bintray 镜像 $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' \u003e\u003e ~/.zshrc $ source ~/.zshrc # bash 替换 brew bintray 镜像 $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' \u003e\u003e ~/.bash_profile $ source ~/.bash_profile # 刷新源 $ brew update ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:3:3","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"3.4 重置为官方源 # 重置 brew.git 为官方源 $ git -C \"$(brew --repo)\" remote set-url origin https://github.com/Homebrew/brew.git # 重置 homebrew-core.git 为官方源 $ git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://github.com/Homebrew/homebrew-core.git # 重置 homebrew-cask.git 为官方源 $ git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://github.com/Homebrew/homebrew-cask # zsh 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 $ vi ~/.zshrc # export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx # bash 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 $ vi ~/.bash_profile # export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx # 刷新源 $ brew update ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:3:4","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["开发配置"],"content":"3 总结 切换成功可以去安装你需要安装的软件了。 ","date":"2021-01-09","objectID":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/:4:0","tags":["开发配置"],"title":"【Brew】Mac 下 brew 切换为国内源","uri":"/04-mac%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"},{"categories":["go"],"content":"介绍Gitee管理你的私有库作为项目依赖包的处理.","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"1 简述 开发项目中，一些通用的包就是被封装为第三方库，可以作为新的项目的依赖包，在公司的情况，使用gitlab环境，配置.netrc文件即可。 那么在家里怎么管理你的依赖包呢，为了稳定的访问，使用国内最大的同性交友平台Gitee管理你的私有库作为项目依赖包的处理。 ","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/:1:0","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"2 开始 ","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/:2:0","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"2.1 SSH公钥添加 头像-\u003e设置-\u003eSSH公钥添加 SSH公钥生成和查看方式 生成 ssh-keygen 运行命令后，按3次回车即可 查看 cat /root/.ssh/id_rsa.pub 检测是否配置成功 ssh git@gitee.com 检测是否有权限 ","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/:2:1","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"2.2 私有仓库的建立 后续补充 ","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/:2:2","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"2.3 本地Git的配置 git config --global url.\"git@gitee.com:\".insteadOf \"https://gitee.com/\" //查看配置情况 cat ~/.gitconfig，只要发现有如下即可. [url \"git@gitee.com:\"] insteadOf = https://gitee.com/ ","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/:2:3","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"2.4 测试 go get -v gitee.com/{YourAccount}/name ","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/:2:4","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"3 总结 基本说明了Gitee管理私有仓库的方法，哈哈哈，依然是没有图。 ","date":"2021-01-08","objectID":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/:3:0","tags":["go"],"title":"【Go】如何使用国内同性交友平台Gitee管理你的私有库","uri":"/17-gitee%E7%AE%A1%E7%90%86go%E9%A1%B9%E7%9B%AE/"},{"categories":["go"],"content":"介绍缓存击穿问题的原因和使用singleflight的解决方法.","date":"2021-01-04","objectID":"/16-singleflight-pkg/","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"1 简介 项目开发的过程中，为了提高服务的并发能力，缓存是其中一个重要的方法，合理和缓存数据可以显著的提高服务的并发能力。 用SingleFlight合并重复请求，singleflight包提供了一种抑制重复函数调用的机制。 具体到Go程序运行的层面来说，SingleFlight的作用是在处理多个goroutine同时调用同一个函数的时候，只让一个goroutine去实际调用这个函数，等到这个goroutine返回结果的时候，再把结果返回给其他几个同时调用了相同函数的goroutine，这样可以减少并发调用的数量。在实际应用中也是，它能够在一个服务中减少对下游的并发重复请求。还有一个比较常见的使用场景是用来防止缓存击穿。 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:1:0","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"2 缓存击穿 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:2:0","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"2.1 什么是缓存击穿 缓存击穿是指缓存中没有但数据库中有的数据（未缓存或者缓存到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力 。简单地说就是缓存过期大量线程访问数据库。 key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:2:1","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"2.2 常见的解决方案 造成缓存穿透的原因有两点： 缓存过期 大量链接访问数据库 常见解决方法： 设置热点数据永远不过期 分级缓存 加锁 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:2:2","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"2.3 缓存处理流程 当缓存失效时，需要去数据存储层获取数据，然后存储到缓存中。 通常缓存更新方案： 业务代码中，根据key从缓存拿不到数据，访问存储层获取数据后更新缓存 由专门的定时脚本在缓存失效前对其进行更新 通过分布式锁，实现只有一个请求负责缓存更新，其他请求等待。 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:2:3","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"3 Go singleflight ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:3:0","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"3.1 Go singleflight的使用 $ go get -u golang.org/x/sync/singleflight package main import ( \"log\" \"sync\" \"time\" \"golang.org/x/sync/singleflight\" ) func main() { var singleSetCache singleflight.Group var wg sync.WaitGroup cacheKey := \"cacheKey\" for i := 0; i \u003c 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() value, err, shared := singleSetCache.Do(cacheKey, func() (ret interface{}, err error) { //do的入参key，可以直接使用缓存的key，这样同一个缓存，只有一个协程会去读DB log.Printf(\"%v exec\", i) time.Sleep(3 * time.Second) return \"value\", nil }) log.Printf(\"value %v, err %v, shared:%v\", value.(string), err, shared) }(i) } wg.Wait() } 输出 2021/01/05 23:18:32 0 exec 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true 2021/01/05 23:18:35 value value, err \u003cnil\u003e, shared:true ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:3:1","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"3.2 Go singleflight的源码分析 Go扩展库里用singleflight.Group结构体类型提供了SingleFlight并发原语的功能。 singleflight.Group类型提供了三个方法： func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) func (g *Group) DoChan(key string, fn func() (interface{}, error)) \u003c-chan Result func (g *Group) Forget(key string) Do方法，接受一个字符串Key和一个待调用的函数，会返回调用函数的结果和错误。使用Do方法的时候，它会根据提供的Key判断是否去真正调用fn函数。同一个 key，在同一时间只有第一次调用Do方法时才会去执行fn函数，其他并发的请求会等待调用的执行结果。 DoChan方法：类似Do方法，只不过是一个异步调用。它会返回一个通道，等fn函数执行完，产生了结果以后，就能从这个 chan 中接收这个结果。 Forget方法：在SingleFlight中删除一个Key。这样一来，之后这个Key的Do方法调用会执行fn函数，而不是等待前一个未完成的fn 函数的结果。 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:3:2","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"4 应用场景 了解了Go语言提供的 SingleFlight并发原语都有哪些方法可以调用后 ，下面介绍两个它的应用场景。 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:4:0","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"4.1 查询DNS记录 Go语言的net标准库里使用的lookupGroup结构，就是Go扩展库提供的原语singleflight.Group type Resolver struct { ...... // 源码地址 https://github.com/golang/go/blob/master/src/net/lookup.go#L151 // lookupGroup merges LookupIPAddr calls together for lookups for the same // host. The lookupGroup key is the LookupIPAddr.host argument. // The return values are ([]IPAddr, error). lookupGroup singleflight.Group } 它的作用是将对相同域名的DNS记录查询合并成一个查询，下面是net库提供的DNS记录查询方法LookupIp使用lookupGroup这个SingleFlight进行合并查询的相关源码，它使用的是异步查询的方法DoChan。 func LookupIP(host string) ([]IP, error) { addrs, err := DefaultResolver.LookupIPAddr(context.Background(), host) ...... } func (r *Resolver) lookupIPAddr(ctx context.Context, network, host string) ([]IPAddr, error) { ...... // 使用SingleFlight的DoChan合并多个查询请求 ch, called := r.getLookupGroup().DoChan(lookupKey, func() (interface{}, error) { defer dnsWaitGroup.Done() return testHookLookupIP(lookupGroupCtx, resolverFunc, network, host) }) if !called { dnsWaitGroup.Done() } select { case \u003c-ctx.Done(): ...... case r := \u003c-ch: lookupGroupCancel() if trace != nil \u0026\u0026 trace.DNSDone != nil { addrs, _ := r.Val.([]IPAddr) trace.DNSDone(ipAddrsEface(addrs), r.Shared, r.Err) } return lookupIPReturn(r.Val, r.Err, r.Shared) } } 上面的源码做了很多删减，只留了SingleFlight合并查询的部分，如果有兴趣可以去GitHub上看一下完整的源码，访问链接https://github.com/golang/go/blob/master/src/net/lookup.go#L261 ，可直接定位到这部分的源码。 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:4:1","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"4.2 防止缓存击穿 在项目里使用缓存时，一个常见的用法是查询一个数据先去查询缓存，如果没有就去数据库里查到数据并缓存到Redis里。那么缓存击穿问题是指，高并发的系统中，大量的请求同时查询一个缓存Key 时，如果这个 Key 正好过期失效，就会导致大量的请求都打到数据库上，这就是缓存击穿。用 SingleFlight 来解决缓存击穿问题再合适不过，这个时候只要这些对同一个 Key 的并发请求的其中一个到数据库中查询就可以了，这些并发的请求可以共享同一个结果。 请求图片请求图片 \" 请求图片 下面是一个模拟用SingleFlight并发原语合并查询Redis缓存的程序，你可以自己动手测试一下，开10个goroutine去查询一个固定的Key，观察一下返回结果就会发现最终只执行了一次Redis查询。 // 模拟一个Redis客户端 type client struct { // ... 其他的配置省略 requestGroup singleflight.Group } // 普通查询 func (c *client) Get(key string) (interface{}, error) { fmt.Println(\"Querying Database\") time.Sleep(time.Second) v := \"Content of key\" + key return v, nil } // SingleFlight查询 func (c *client) SingleFlightGet(key string) (interface{}, error) { v, err, _ := c.requestGroup.Do(key, func() (interface{}, error) { return c.Get(key) }) if err != nil { return nil, err } return v, err } 完整的测试源码可以点击阅读原文，去我的GitHub仓库下载 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:4:2","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"5 实现原理 最后我们来看一下singleflight.Group的实现原理，通过它的源码也是能学到不少用Go语言编程的技巧的。singleflight.Group由一个互斥锁sync.Mutex和一个映射表组成，每一个 singleflight.call结构体都保存了当前调用对应的信息： type Group struct { mu sync.Mutex m map[string]*call } type call struct { wg sync.WaitGroup val interface{} err error dups int chans []chan\u003c- Result } 下面我们来看看 Do 和 DoChan 方法是怎么实现的。 ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:5:0","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"5.1 Do方法 SingleFlight 定义一个call结构体，每个结构体都保存了fn调用对应的信息。 Do方法的执行逻辑是每次调用Do方法都会先去获取互斥锁，随后判断在映射表里是否已经有Key对应的fn函数调用信息的call结构体。 当不存在时，证明是这个Key的第一次请求，那么会初始化一个call结构体指针，增加SingleFlight内部持有的sync.WaitGroup计数器到1。释放互斥锁，然后阻塞的等待doCall方法执行fn函数的返回结果 当存在时，增加call结构体内代表fn重复调用次数的计数器dups，释放互斥锁，然后使用WaitGroup等待fn函数执行完成。 call结构体的val 和 err 两个字段只会在 doCall方法中执行fn有返回结果后才赋值，所以当 doCall方法 和 WaitGroup.Wait返回时，函数调用的结果和错误会返回给Do方法的所有调用者。 func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) { g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { // 存在相同的key, 增加计数 c.dups++ g.mu.Unlock() c.wg.Wait() //等待这个key对应的fn调用完成 return c.val, c.err, true // 返回fn调用的结果 } c := new(call) // 不存在key, 是第一个请求, 创建一个call结构体 c.wg.Add(1) g.m[key] = c //加入到映射表中 g.mu.Unlock() g.doCall(c, key, fn) // 调用方法 return c.val, c.err, c.dups \u003e 0 } doCall方法会去实际调用fn函数，因为call结构体初始化后forgotten字段的默认值是false，fn调用有返回后，会把对应的Key删掉。这样这轮请求都返回后，下一轮使用同一的Key的请求会重新调用执行一次fn函数。 func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) { c.val, c.err = fn() c.wg.Done() g.mu.Lock() if !c.forgotten { // 已调用完，删除这个key delete(g.m, key) } for _, ch := range c.chans { ch \u003c- Result{c.val, c.err, c.dups \u003e 0} } g.mu.Unlock() } ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:5:1","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"5.2 DoChan方法 SingleFlight还提供了异步调用DoChan方法，它的执行逻辑和Do方法类似，唯一不同的是调用者不用阻塞等待调用的返回， DoChan方法会创建一个chan Result通道返回给调用者，调用者通过这个通道就能接受到fn函数的结果。这个chan Result通道，在返回给调用者前会先放到call结构体的维护的通知队列里，待fn函数返回结果后DoChan方法会把结果发送给通知队列中的每个通道。 func (g *Group) DoChan(key string, fn func() (interface{}, error)) \u003c-chan Result { ch := make(chan Result, 1) g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { c.dups++ c.chans = append(c.chans, ch) g.mu.Unlock() return ch } c := \u0026call{chans: []chan\u003c- Result{ch}} c.wg.Add(1)s g.m[key] = c g.mu.Unlock() go g.doCall(c, key, fn) return ch } type Result struct { Val interface{} Err error Shared bool } ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:5:2","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"6 总结 基本梳理了Go singleflight的使用方法及其代码的原理，代码及其的精炼，值得学习和分享代码的使用。 []: \u003c\u003e ","date":"2021-01-04","objectID":"/16-singleflight-pkg/:6:0","tags":["go"],"title":"【Go】singleflight 100行代码解决缓存击穿问题","uri":"/16-singleflight-pkg/"},{"categories":["go"],"content":"golang的benchmark测试具体使用方法和一些测试的demo案例.","date":"2021-01-01","objectID":"/14-benchmark-test/","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"简介 benchmark基准测试是一种测试代码性能的方法，同时也可以用来判断某段代码的CPU或者内存效率问题。很多开发都是通过benchmark测试的结果来衡量一个函数或者功能的性能表现。一个优秀的程序员不仅需要写好自己的业务代码，其次测试代码的质量也是衡量的一个重要标准。一个完整的单元测试和性能测试，至少可以发现80%的bug。 以下以Go语言为案例，说说go的benchmark测试。 ","date":"2021-01-01","objectID":"/14-benchmark-test/:1:0","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"1 准备 压力测试的环境，必须同一个测试环境，修改前后才有对比可言。 压力测试的环境，最好和线上运行的系统相同，建议使用linux，有条件的可以与线上系统的配置相同。 机器处于闲置状态，测试时不要执行其他任务，也不要和其他人共享硬件资源。 ","date":"2021-01-01","objectID":"/14-benchmark-test/:2:0","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"2 benchmark测试 ","date":"2021-01-01","objectID":"/14-benchmark-test/:3:0","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"2.1 测试环境的搭建 ​ Go 语言标准库内置的 testing 测试框架提供了基准测试benchmark的能力，能让我们很容易地对某一段代码进行性能试。benchmark的测试方式和普通的测试方式相同，创建的测试文件都需要以_test.go结尾。一般测试的情况，都是一个源文件代码会对应一个测试文件。测试文件的量可以会远超业务代码的量。 使用命命令行操作： $ mkdir benchmark $ cd benchmark $ vim main.go main.go 测试什么程序的性能呢？这个问题我想了很久。排序算法？ package main import \"fmt\" func main() { arr := []int{8, 4, 2, 9, 10, -3, 3, 20, 15, -1} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { length := len(arr) for i := 0; i \u003c length-1; i++ { flag := true for j := 0; j \u003c length-1-i; j++ { if arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] flag = false } } if flag { break } } } 新建测试程序，编写测试代码 vim main_test.go package main import ( \"math/rand\" \"testing\" \"time\" ) var intArray []int func TestMain(m *testing.M) { rand.Seed(time.Now().Unix()) intArray = make([]int, 10000) for i := 0; i \u003c 10000; i++ { intArray[i] = rand.Int() } m.Run() } func Benchmark_bubbleSort(b *testing.B) { slice := intArray[0:10000] for i := 0; i \u003c b.N; i++ { bubbleSort(slice) } } benchmark 和普通的单元测试用例是使用，测试文件都是需要_test.go 结尾命名。 函数名以 Benchmark 开头，参数是 b *testing.B。 func TestMain(m *testing.M)是测试前运行的数据，这边是实现随机一组int类型的数据。 这样我们的测试环境就搭建好了，可以开始执行我们的测试了。 ","date":"2021-01-01","objectID":"/14-benchmark-test/:3:1","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"2.2 Go test 执行测试用例 $ go test -bench . goos: darwin goarch: amd64 pkg: benchmark Benchmark_bubbleSort-8 99993 11892 ns/op PASS ok benchmark 4.550s 在测试目录执行go test，使用 go test -bench .执行当前目录下的所有benchmark测试单元。 如果目录下有很多的测试单元，你只想执行其中一个怎么办？ -bench参数支持使用正则表达式，正则表达式匹配到的benchmark测试才会执行。 $ go test -bench='^bubbleSort$' . $ go test -bench='bubbleSort' . goos: darwin goarch: amd64 pkg: benchmark Benchmark_bubbleSort-8 99130 12216 ns/op PASS ok benchmark 2.601s benchmark执行的过程中，过滤单元测试的输出 -run匹配一个从来没有单元测试的方法，过滤单元测试的输出，可以使用以下两种的测试方法： -run=none -run=^$ eg: go test -bench=. -run=none go test -bench=. -run=^$ ","date":"2021-01-01","objectID":"/14-benchmark-test/:3:2","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"2.3 Go test的一些扩展参数 2.3.1 准确度的提升 正确的使用扩展参数的情况，能提高单元测试精确度。 -benchtime和-count参数-cpu -benchtime 测试时间 go test -bench=. -benchtime=5s . $ go test -bench=. -benchtime=5s . goos: darwin goarch: amd64 pkg: benchmark Benchmark_bubbleSort-8 502545 12027 ns/op PASS ok benchmark 11.097s ​ 为什么时间是 11.097s 不是 5s，测试用例编译、执行、销毁等是需要时间的。 测试次数 go test -bench=. -benchtime=5x . $ go test -bench=. -benchtime=5x . goos: darwin goarch: amd64 pkg: benchmark Benchmark_bubbleSort-8 5 16795 ns/op PASS ok benchmark 0.388s -cpu 设置cpu使用个数对程序的性能的影响。 go test -bench=. -cpu=2,4,8 . $ go test -bench=. -cpu=2,4,8 . goos: darwin goarch: amd64 pkg: benchmark Benchmark_bubbleSort-2 97129 12054 ns/op Benchmark_bubbleSort-4 98277 11940 ns/op Benchmark_bubbleSort-8 99444 11927 ns/op PASS ok benchmark 5.012s ​ 为什么2，4，8核心的性能几乎是一样的？因为没有使用到多线程的机制，写的demo是串行的。 2.3.2 实现内存的统计 -benchmem go test -bench=. -benchmem goos: darwin goarch: amd64 pkg: benchmark Benchmark_bubbleSort-8 100401 11959 ns/op 0 B/op 0 allocs/op PASS ok benchmark 2.624s ","date":"2021-01-01","objectID":"/14-benchmark-test/:3:3","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"3 benchmark扩展和原理分析 ","date":"2021-01-01","objectID":"/14-benchmark-test/:4:0","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"3.1 精确耗时处理 ResetTimer 受到耗时准备任务的干扰情况，使用ResetTimer重置时间。 StopTimer 和 StartTimer 每次函数调用前后需要一些准备工作和清理工作，可以使用 StopTimer 暂停计时以及使用 StartTimer 开始计时。 ","date":"2021-01-01","objectID":"/14-benchmark-test/:4:1","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"3.2 原理简单说明 func Benchmark_bubbleSort(b *testing.B) { slice := intArray[0:10000] for i := 0; i \u003c b.N; i++ { bubbleSort(slice) } } ​ 通过demo可以看到，benchmark测试的时候，使用的参数为b *testing.B，有一个很重要用到的数据类型为b.N，通过for循环可以看出，是用例需要执行的次数。b.N对于每个用例测试可能都是不一样的。 那这个b.N的数值的N是如何决定的呢？ ​ b.N从1开始，如果测试的用例可以在 1s 内完成，b.N的值增加，再次的去执行。b.N的值大概是以指数的方式序列递增，越到后面，增加的越快。 demo: func BenchmarkSleep1s(b *testing.B) { for i := 0; i \u003c b.N; i++ { time.Sleep(time.Second * 1) } } 测试命令 $ go test -bench=\"Sleep\" goos: darwin goarch: amd64 pkg: benchmark BenchmarkSleep1s-8 1 1002035924 ns/op PASS ok benchmark 1.438s 为什么只执行一次的话，应该就是上面的方式方法。 ","date":"2021-01-01","objectID":"/14-benchmark-test/:4:2","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["go"],"content":"总结 介绍了benchmark的使用，以及相关扩展参数的使用方法。快去实践一下吧？ 后续的话，介绍使用pprof进行性能的分析。 ","date":"2021-01-01","objectID":"/14-benchmark-test/:5:0","tags":["go"],"title":"【Go】性能分析之benchmark基准测试","uri":"/14-benchmark-test/"},{"categories":["编程"],"content":"研究微软产品，官方文档推荐使用的内网穿透工具.","date":"2020-12-31","objectID":"/11-ngrok/","tags":["编程"],"title":"【ngrok】微软推荐的使用内网穿透工具","uri":"/11-ngrok/"},{"categories":["编程"],"content":"简述 ​ 内网穿透很多情况都会使用到，目前很多服务使用webhook的方式的话，有一个外网能响应到内网服务的方式是非常有必要的。尝试了几个工具之后，最终给大家推荐一个软件，就是今天主题，ngrok。跨平台，window、linux、mac都ok。 ","date":"2020-12-31","objectID":"/11-ngrok/:1:0","tags":["编程"],"title":"【ngrok】微软推荐的使用内网穿透工具","uri":"/11-ngrok/"},{"categories":["编程"],"content":"开始 ","date":"2020-12-31","objectID":"/11-ngrok/:2:0","tags":["编程"],"title":"【ngrok】微软推荐的使用内网穿透工具","uri":"/11-ngrok/"},{"categories":["编程"],"content":"环境的安装 官方网站：ngrok 下载对应的版本 几个环境的版本都是使用压缩包的新式，解压即可使用。 ","date":"2020-12-31","objectID":"/11-ngrok/:2:1","tags":["编程"],"title":"【ngrok】微软推荐的使用内网穿透工具","uri":"/11-ngrok/"},{"categories":["编程"],"content":"获取认证token 注册账号 获取token Authentication -\u003e Your Authtoken ","date":"2020-12-31","objectID":"/11-ngrok/:2:2","tags":["编程"],"title":"【ngrok】微软推荐的使用内网穿透工具","uri":"/11-ngrok/"},{"categories":["编程"],"content":"运行测试 简单使用 // 填写token $ ./ngrok authtoken {authtoken} Authtoken saved to configuration file: /Users/coolliuzw/.ngrok2/ngrok.yml # 配置文件生成地址 /Users/coolliuzw/.ngrok2/ngrok.yml // 内网穿透http 8080 端口 $ ./ngrok http 8080 ngrok by @inconshreveable (Ctrl+C to quit) Session Status online Account coolliuzw (Plan: Free) Version 2.3.35 Region United States (us) Web Interface http://127.0.0.1:4040 Forwarding http://e297d4f71578.ngrok.io -\u003e http://localhost:8080 Forwarding https://e297d4f71578.ngrok.io -\u003e http://localhost:8080 Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 配置文件使用 ngrok.yml authtoken:{authtoken}tunnels:http:proto:httpaddr:8080 $ ./ngrok start -all Session Status online Account coolliuzw (Plan: Free) Version 2.3.35 Region United States (us) Web Interface http://127.0.0.1:4040 Forwarding http://d174cf132c6a.ngrok.io -\u003e http://localhost:8080 Forwarding https://d174cf132c6a.ngrok.io -\u003e http://localhost:8080 Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 ","date":"2020-12-31","objectID":"/11-ngrok/:2:3","tags":["编程"],"title":"【ngrok】微软推荐的使用内网穿透工具","uri":"/11-ngrok/"},{"categories":["编程"],"content":"总结 介绍了ngrok的使用，基本能满足使用。需要更具体的使用方法的可以查看官网，基本free版本的就够我们日常使用了，如果有特殊需求的话可以使用付费版本。 ~ 小任务：尝试搭建本地搭建一个http服务，使用手机访问服务得到响应。 ","date":"2020-12-31","objectID":"/11-ngrok/:3:0","tags":["编程"],"title":"【ngrok】微软推荐的使用内网穿透工具","uri":"/11-ngrok/"},{"categories":["编程"],"content":"搭建demo验证go-zero程序，主要说明了一下需要使用到的环境安装方法.","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":" 官方教程 ","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/:0:0","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":"简述 go-zero的微服务的框架，从开源就开始关注了，当时自己才刚入门Go语言，对一些微服务的策略都没有什么概念。 目前对Go语言有了基本的了解，准备看官方文档对Go较深度的学习一下。 按照官方的实例。包括相关环境的安装教程。 ","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/:1:0","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":"开始 ","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/:2:0","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":"书店微服务框架架构图 ","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/:2:1","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":"环境安装 后期环境的安装，尽量使用docker的方式实现 redis环境安装 查询redis列表 docker search redis 拉取最新版本 docker pull redis:latest 查看redis镜像 docker images | grep redis 开始运行redis docker run -itd --name redis -p 6379:6379 redis 查看是否运行成功 docker ps -a | grep redis 使用通过redis-cli连接测试使用redis服务 docker exec -it redis-test /bin/bash redis-cli ping shutdown 退出 docker-cli 再使用exit退出 Linux环境使用Docker安装Redis以及初步使用 etcd环境安装 docker pull gcr.io/etcd-development/etcd:v3.4.14 docker pull quay.io/coreos/etcd:v3.4.14 $ rm -rf /tmp/etcd-data.tmp \u0026\u0026 mkdir -p /tmp/etcd-data.tmp \u0026\u0026 \\ docker rmi quay.io/coreos/etcd:v3.4.14 || true \u0026\u0026 \\ docker run \\ -p 2379:2379 \\ -p 2380:2380 \\ --mount type=bind,source=/tmp/etcd-data.tmp,destination=/etcd-data \\ --name etcd-gcr-v3.4.14 \\ quay.io/coreos/etcd:v3.4.14 \\ /usr/local/bin/etcd \\ --name s1 \\ --data-dir /etcd-data \\ --listen-client-urls http://0.0.0.0:2379 \\ --advertise-client-urls http://0.0.0.0:2379 \\ --listen-peer-urls http://0.0.0.0:2380 \\ --initial-advertise-peer-urls http://0.0.0.0:2380 \\ --initial-cluster s1=http://0.0.0.0:2380 \\ --initial-cluster-token tkn \\ --initial-cluster-state new \\ --log-level info \\ --logger zap \\ --log-outputs stderr // 测试 docker exec etcd-gcr-v3.4.14 /bin/sh -c \"/usr/local/bin/etcd --version\" docker exec etcd-gcr-v3.4.14 /bin/sh -c \"/usr/local/bin/etcdctl version\" docker exec etcd-gcr-v3.4.14 /bin/sh -c \"/usr/local/bin/etcdctl endpoint health\" docker exec etcd-gcr-v3.4.14 /bin/sh -c \"/usr/local/bin/etcdctl put foo bar\" docker exec etcd-gcr-v3.4.14 /bin/sh -c \"/usr/local/bin/etcdctl get foo\" mysql环境安装 # 下载Mysql 5.7 镜像 $ docker pull mysql:5.7 $ mkdir /Users/liuzhiwei/code/mysql/{conf,logs,mysql} $ docker run -d -p 3306:3306 --name mysql \\ -v /Users/liuzhiwei/code/mysql/conf:/etc/mysql \\ -v /Users/liuzhiwei/code/mysql/logs:/var/log/mysql \\ -v /Users/liuzhiwei/code/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=admin \\ mysql:5.7 bb61d23735223052f1c4b731bd2710be01a9b60d0ec8bff899752470a2f6ba73 安装etcd, mysql, redis 安装protoc-gen-go go get -u github.com/golang/protobuf/protoc-gen-go 安装goctl工具 GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero/tools/goctl ","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/:2:2","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":"创建测试项目 按照文档测试就ok 注意rpc服务的配置文件 DataSource: root:admin@tcp(localhost:3306)/gozero MySQL的数据库的表的话，自己手动去创建就好了。 ","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/:2:3","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":"总结 环境搭建好，最好还是测试成功了，MySQL没有白入门，哈哈。 go-zero确实有点强，基础的几行代码就能实现一个高并发的微服务，使用到redis和MySQL和etcd三个服务，搭建都是使用docker的方式。 ","date":"2020-12-27","objectID":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/:3:0","tags":["编程"],"title":"【微服务】go-zero微服务框架实现书店服务","uri":"/10-go-zero%E7%9A%84demo%E5%AE%9E%E7%8E%B0/"},{"categories":["编程"],"content":"介绍我的MySQL的学习计划和相关动机.","date":"2020-12-26","objectID":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/","tags":["编程"],"title":"【mysql】准备学习 MySQL Plan计划","uri":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/"},{"categories":["编程"],"content":"简述 ​ 说说目前我的情况， 之前基本上两年的c的服务器开发经验。之前开发中，所有关于操作数据库处理MySQL MongoDB等相关数据库的CRUD都是调用其他服务的HTTP接口进行，没有直接进行操作的部分。数据库的部分，由其他部分的成员设计的开发，似乎我们只懂调用HTTP的接口获取和存储信息。 ​ 目前的话，有直接使用的是对接redis非关系型的数据库，MySQL还是没有接触过，不知道如何使用。 ​ 但是作为服务器开发的程序员，what，不会MySQL数据库有点说不过去？ ​ 那就一起学习起来。 ","date":"2020-12-26","objectID":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/:1:0","tags":["编程"],"title":"【mysql】准备学习 MySQL Plan计划","uri":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/"},{"categories":["编程"],"content":"动机 学习的话，应该需要有目的学习，也不要盲目的学习，之前想研究一下JAVA的，目前时间原因以及工作也不会用到，准备暂时不继续。 动机 部分开源项目有设计到使用MySQL的情况，学习有时候会因为这个卡住。 作为服务器开发程序员，没有直接使用到，但是也要懂得基础的概念，可以知道怎么让其他的服务提供接口。 想了解一下，不然被朋友问到不知s道有点尴尬的样子，服务器开发，不会MySQL？what? ","date":"2020-12-26","objectID":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/:2:0","tags":["编程"],"title":"【mysql】准备学习 MySQL Plan计划","uri":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/"},{"categories":["编程"],"content":"学习方式 文档： MySQL 教程 视频 系统看书（有开发使用情况在考虑，目前只想基本的有一个概念和会使用） ","date":"2020-12-26","objectID":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/:3:0","tags":["编程"],"title":"【mysql】准备学习 MySQL Plan计划","uri":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/"},{"categories":["编程"],"content":"总结 学习的过程中，也会输出一部分的笔记记录相关学习情况，如环境如何搭建和测试，等等。 ","date":"2020-12-26","objectID":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/:4:0","tags":["编程"],"title":"【mysql】准备学习 MySQL Plan计划","uri":"/01-mysql%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%9C%BA/"},{"categories":["go"],"content":"ErrorGroup的简介和学习探索.","date":"2020-12-26","objectID":"/13-err-group/","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":" 引用文章觉得WaitGroup不好用？试试ErrorGroup吧！ ","date":"2020-12-26","objectID":"/13-err-group/:0:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"简介 sync.WaitGroup在并发编程里面使用频率非常高，通常用于协同等待的场景，学习基础的Go并发编程的同学应该没有不懂它的使用方法。 ","date":"2020-12-26","objectID":"/13-err-group/:1:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"WaitGroup简单介绍 看看下面这个代码： func main() { cost := time.Now() for i := 0; i \u003c 5; i++ { go func(i int) { fmt.Println(i) }(i) } // time.Sleep 具体什么作用呢？ time.Sleep(time.Second * 1) fmt.Printf(\"cost:%v ms\", time.Since(cost).Milliseconds()) } 0 4 1 2 3 cost:1004 ms 我相信大家应该很清楚，time.Sleep()在这边的作用。同样的sync.WaitGroup也是起到等待完成的作用。 一个goroutine在检查点(Check Point)等待一组执行任务的 worker goroutine 全部完成，如果在执行任务的这些worker goroutine 还没全部完成，等待的 goroutine 就会阻塞在检查点，直到所有woker goroutine 都完成后才能继续执行。 改改代码使用sync.WaitGroup的方式 func main() { cost := time.Now() wg := sync.WaitGroup{} for i := 0; i \u003c 5; i++ { wg.Add(1) go func(i int) { defer wg.Done() fmt.Println(i) }(i) } wg.Wait() fmt.Printf(\"cost:%v ms\", time.Since(cost).Milliseconds()) } // 输出 4 1 0 2 3 cost:0 ms 为什么两个程序时间差距这么大，你应该明白了，原因在于怎么实现等的操作。怎么保证可靠性的等待。 ","date":"2020-12-26","objectID":"/13-err-group/:2:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"WaitGroup存在的问题 ​ 如果在woker goroutine的执行过程中遇到错误想要通知在检查点等待的协程处理该怎么办呢？WaitGroup并没有提供传播错误的功能。 ","date":"2020-12-26","objectID":"/13-err-group/:3:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"ErrorGroup介绍 ​ Go语言在扩展库提供的ErrorGroup并发原语正好适合在这种场景下使用，它在WaitGroup的功能基础上还提供了，错误传播以及上下文取消的功能。 Go扩展库通过errorgroup.Group提供ErrorGroup原语的功能，它有三个方法可调用： func WithContext(ctx context.Context) (*Group, context.Context) func (g *Group) Go(f func() error) func (g *Group) Wait() error 调用errorgroup包的WithContext方法会返回一个Group 实例，同时还会返回一个使用 context.WithCancel 生成的新Context。一旦有一个子任务返回错误，或者是Wait 调用返回，这个新 Context 就会被 cancel。 Go方法，接收类型为func() error 的函数作为子任务函数，如果任务执行成功，就返回nil，否则就返回 error，并且会cancel 那个新的Context。 Wait方法，类似WaitGroup的 Wait 方法，调用后会阻塞地等待所有的子任务都完成，它才会返回。如果有多个子任务返回错误，它只会返回第一个出现的错误，如果所有的子任务都执行成功，就返回nil。 ","date":"2020-12-26","objectID":"/13-err-group/:4:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"使用ErrorGroup go get -u 接下来我们让主goroutine使用ErrorGroup代替WaitGroup等待所有子任务的完成，ErrorGroup有一个特点是会返回所有执行任务的goroutine遇到的第一个错误。我们试着执行一下下面的程序，注意观察程序的输出。 package main import ( \"fmt\" \"log\" \"time\" \"golang.org/x/sync/errgroup\" ) func main() { var eg errgroup.Group for i := 0; i \u003c 100; i++ { i := i eg.Go(func() error { time.Sleep(2 * time.Second) if i \u003e 90 { fmt.Println(\"Error:\", i) return fmt.Errorf(\"Error occurred: %d\", i) } fmt.Println(\"End:\", i) return nil }) } if err := eg.Wait(); err != nil { log.Fatal(err) } } 上面程序，遇到i大于90的都会产生错误结束执行，但是只有第一个执行时产生的错误被ErrorGroup返回，程序的输出大概如下： ...... End: 49 End: 26 Error: 98 End: 63 End: 39 End: 50 End: 38 Error: 95 End: 67 End: 65 End: 57 End: 64 2020/12/17 18:11:40 Error occurred: 98 复制代码 最早执行遇到错误的goroutine输出了Error: 98但是所有未执行完的其他任务并没有停止执行。那么想让程序遇到错误就终止其他子任务该怎么办呢？我们可以用errgroup.Group提供的WithContext方法创建一个带可取消上下文功能的ErrorGroup。 package main import ( \"context\" \"fmt\" \"log\" \"time\" \"golang.org/x/sync/errgroup\" ) func main() { eg, ctx := errgroup.WithContext(context.Background()) for i := 0; i \u003c 100; i++ { i := i eg.Go(func() error { time.Sleep(2 * time.Second) select { case \u003c-ctx.Done(): fmt.Println(\"Canceled:\", i) return nil default: if i \u003e 90 { fmt.Println(\"Error:\", i) return fmt.Errorf(\"Error: %d\", i) } fmt.Println(\"End:\", i) return nil } }) } if err := eg.Wait(); err != nil { log.Fatal(err) } } Go方法单独开启的goroutine在执行参数传递进来的函数时，如果函数返回了错误，会对ErrorGroup持有的err字段进行赋值并及时调用cancel函数，通过上下文通知其他子任务取消执行任务。所以上面更新后的程序会有如下类似的输出。 ...... Error: 99 Canceled: 68 Canceled: 85 End: 57 End: 51 Canceled: 66 Canceled: 93 Canceled: 72 Canceled: 78 End: 55 Canceled: 74 2020/12/17 18:23:12 Error: 99 了解ErrorGroup的使用方法后，我们再来看看这个并发同步原语的实现原理。 ","date":"2020-12-26","objectID":"/13-err-group/:5:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"ErrorGroup的实现原理 ErrorGroup原语的结构体类型errorgroup.Group定义如下： type Group struct { cancel func() wg sync.WaitGroup errOnce sync.Once err error } cancel — 创建 context.Context 时返回的取消函数，用于在多个 goroutine 之间同步取消信号； wg — 用于等待一组 goroutine 完成子任务的同步原语； errOnce — 用于保证只接收一个子任务返回的错误的同步原语； 通过 errgroup.WithContext构造器创建errgroup.Group 结构体： func WithContext(ctx context.Context) (*Group, context.Context) { ctx, cancel := context.WithCancel(ctx) return \u0026Group{cancel: cancel}, ctx } 运行新的并行子任务需要使用errgroup.Group.Go方法，这个方法的执行过程如下： 调用 sync.WaitGroup.Add 增加待处理的任务数； 创建一个新的 goroutine 并在 goroutine 内部运行子任务； 返回错误时及时调用 cancel 并对 err 赋值，只有最早返回的错误才会被上游感知到，后续的错误都会被舍弃： func (g *Group) Go(f func() error) { g.wg.Add(1) go func() { defer g.wg.Done() if err := f(); err != nil { g.errOnce.Do(func() { g.err = err if g.cancel != nil { g.cancel() } }) } }() } 用于等待的errgroup.Group.Wait方法只是调用了 sync.WaitGroup.Wait方法，阻塞地等待所有子任务完成。在子任务全部完成时会通过调用在errorgroup.WithContext创建Group和Context对象时存放在Group.cancel字段里的函数，取消Context对象并返回可能出现的错误。 func (g *Group) Wait() error { g.wg.Wait() if g.cancel != nil { g.cancel() } return g.err } ","date":"2020-12-26","objectID":"/13-err-group/:6:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"总结 Go语言通过errorgroup.Group结构提供的ErrorGroup原语通过封装WaitGroup、Once基本原语结合上下文对象，提供了除同步等待外更加复杂的错误传播和执行任务取消的功能。在使用时，我们也需要注意它的两个特点： errgroup.Group在出现错误或者等待结束后都会调用 Context对象 的 cancel 方法同步取消信号。 只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。 ","date":"2020-12-26","objectID":"/13-err-group/:7:0","tags":["go"],"title":"【Go】用ErrorGroup替代你的WaitGroup","uri":"/13-err-group/"},{"categories":["go"],"content":"简述 Go作为21世纪的c语言，并发开发的难道很低，使用goroutine协程的成本也很低。所以goroutine的并发开发在开发程序当中被大量的使用，但是goroutine的开发也有不少的坑和陷阱，这篇文章总结一些场景的坑和陷阱以及规避的方法。 ","date":"2020-12-26","objectID":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/:1:0","tags":["go"],"title":"【Go】Go并发陷阱和有效规避方法","uri":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/"},{"categories":["go"],"content":"闭包专递参数问题 循环并发时闭包传递参数的问题，先看一个实例 func main() { wg := sync.WaitGroup{} for i := 0; i \u003c 5; i++ { wg.Add(1) go func() { wg.Done() fmt.Println(i) }() } wg.Wait() } 运行测试输出（大概率，可能你的多测试的话，会有其他的情况，但是预计 0，1，2，3，4基本为0）： 5 5 5 5 5 原因分析： i的变量只被声明了一次，i使用的地址空间在循环中被复用，当子的goroutine函数执行打印时，ii的值可能已经被主的goroutine的i++修改了值，从而导致了并发错误。针对这种错误可以通过复制拷贝或者传参拷贝的方式规避。 ","date":"2020-12-26","objectID":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/:2:0","tags":["go"],"title":"【Go】Go并发陷阱和有效规避方法","uri":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/"},{"categories":["go"],"content":"panic 异常 panic 异常的出现会导致 Go 程序的崩溃。 但其实即使 panic 是出现在其他启动的子 goroutine 中，也会导致 Go 程序的崩溃退出，同时 panic 只能捕获 goroutine 自身的异常，因此对于每个启动的 goroutine，都需要在入口处捕获 panic，并尝试打印堆栈信息并进行异常处理，从而避免子 goroutine 的 panic 导致整个程序的崩溃退出。如下面的例子所示： func Recover() { // 从 panic 中恢复并打印栈信息 if e := recover(); e != nil { buf := make([]byte, 1024) buf = buf[:runtime.Stack(buf, false)] fmt.Printf(\"[PANIC]%v\\n%s\\n\", e, buf) } } func main() { wg := sync.WaitGroup{} for i := 0; i \u003c 5; i++ { wg.Add(1) go func() { wg.Done() defer Recover() panic(\"err\") }() } wg.Wait() time.Sleep(time.Second * 1) fmt.Println(\"success.\") } Goroutine的panic捕获是独立的，父的goroutine的recover无法继承到子的goroutine，一定要注意这个点。 ","date":"2020-12-26","objectID":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/:3:0","tags":["go"],"title":"【Go】Go并发陷阱和有效规避方法","uri":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/"},{"categories":["go"],"content":"超时控制 善于结合使用 select、timer 和 context 进行超时控制。在 goroutine 中进行一些耗时较长的操作，最好都加上超时timer，在并发的时候也要传递 context，这样在取消的时候就不会有遗漏，进而达到回收 goroutine 的目的，避免内存泄漏的发生。如下面的例子所示，通过 select 同时监听任务和定时器状态，在定时器到达而任务未完成之时，提前结束任务，清理资源并返回。 select { // do logic process case msg \u003c- input: .... // has been canceled case \u003c-ctx.Done(): // ...资源清理 return // 2 second timeout case \u003c-time.After(time.Second * 2) // ...资源清理 return default: } ","date":"2020-12-26","objectID":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/:4:0","tags":["go"],"title":"【Go】Go并发陷阱和有效规避方法","uri":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/"},{"categories":["go"],"content":"总结 说明了几种可能出现的错误，和原因的分析，但是没有给出明确的解决示例代码，根据原因分析说明，自己去实践解决问题吧 问题出现原因可能远不止这些，后续可能会总结继续完善本篇文章。 ","date":"2020-12-26","objectID":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/:5:0","tags":["go"],"title":"【Go】Go并发陷阱和有效规避方法","uri":"/12-go-%E5%B9%B6%E5%8F%91%E9%99%B7%E9%98%B1/"},{"categories":["tools"],"content":"centos7的镜像构建，自定义一个属于自己的docker镜像.","date":"2020-12-26","objectID":"/06-my-centos7/","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"简介 平时开发和环境运行的情况，都需要使用到linux的环境，但是每个人使用的环境不同，特点也不同。今天来介绍一下怎么自定义自己的docker镜像和打包。 以下介绍以为我的基础镜像。 ","date":"2020-12-26","objectID":"/06-my-centos7/:1:0","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"开始 ","date":"2020-12-26","objectID":"/06-my-centos7/:2:0","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"获取centos7的基础镜像 docker pull ansible/centos7-ansible ","date":"2020-12-26","objectID":"/06-my-centos7/:2:1","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"运行基础镜像 docker run -d -it --network=host --restart=always --name=my_centos7 --privileged 688353a31fde /usr/sbin/init ","date":"2020-12-26","objectID":"/06-my-centos7/:2:2","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"进入镜像 docker exec -it my_centos7 bash ","date":"2020-12-26","objectID":"/06-my-centos7/:2:3","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"centos7切换阿里云源 参考：设置方法参考链接 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache ","date":"2020-12-26","objectID":"/06-my-centos7/:2:4","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"zsh及插件的安装 插件： git zsh-autosuggestions zsh-syntax-highlighting autojump yum -y install zsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting yum -y install autojump vim ~/.zshrc plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump) ZSH_THEME=\"ys\" source ~/.zshrc ","date":"2020-12-26","objectID":"/06-my-centos7/:2:5","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"fzf的安装 git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf ~/.fzf/install ","date":"2020-12-26","objectID":"/06-my-centos7/:2:6","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"相关高频使用软件安装 yum -y install vim lrzsz tcpdump telnet gdb gcc gcc-c++ wget git unzip zip bash-completion net-tools yum-plugin-security ","date":"2020-12-26","objectID":"/06-my-centos7/:2:7","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"go环境安装 $ wget https://golang.google.cn/dl/go1.15.6.linux-amd64.tar.gz $ tar -C /usr/local -xzf go1.15.6.linux-amd64.tar.gz $ rm -fr go1.15.6.linux-amd64.tar.gz $ vim ~/.zshrc # 尾行添加 export PATH=$PATH:/usr/local/go/bin $ source ~/.zshrc $ go version go version go1.15.6 linux/amd64 go mod 和 go proxy 配置 $ go env -w GO111MODULE=on $ go env -w GOPROXY=\"https://goproxy.cn,direct\" dlv工具安装 go get github.com/go-delve/delve/cmd/dlv ~/.zshrc export PATH=$PATH:/root/go/bin ","date":"2020-12-26","objectID":"/06-my-centos7/:2:8","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"graphviz安装 pprof分析的时候会用到 $ yum -y install graphviz ","date":"2020-12-26","objectID":"/06-my-centos7/:2:9","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"coredump环境配置 ulimit -c unlimited $ echo core.%e.%p\u003e/proc/sys/kernel/core_pattern $ cat /proc/sys/kernel/core_pattern core.%e.%p ","date":"2020-12-26","objectID":"/06-my-centos7/:2:10","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"清除安装缓存 $ yum clean all ","date":"2020-12-26","objectID":"/06-my-centos7/:2:11","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"总结 主要介绍了相关的centos插件，fzf，oh-my-zsh及其插件大量的提高的使用linux的效率，必须学会哦。 ~ ~ 无图，见谅自己是测试吧 链接: https://pan.baidu.com/s/1I700VXCVCzCMgdpNPBworw 密码: t9ul 分享镜像 ","date":"2020-12-26","objectID":"/06-my-centos7/:3:0","tags":["tools"],"title":"【docker】基于centos7的开发镜像构建","uri":"/06-my-centos7/"},{"categories":["tools"],"content":"记录goland安装常用的插件.","date":"2020-12-24","objectID":"/05-goland-plugins/","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"简述 工具忠实粉丝和爱好者，程序员一定要善用工具。相关工具使用好可以大大的提高你的开发效率。 记录自己goland的安装的相关插件，怕自己哪台重装系统的时候把什么工具给忘记安装了。 ","date":"2020-12-24","objectID":"/05-goland-plugins/:1:0","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"按类别划分 ","date":"2020-12-24","objectID":"/05-goland-plugins/:2:0","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"vim 必备插件 IdeaVim ","date":"2020-12-24","objectID":"/05-goland-plugins/:2:1","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"主题美化相关 Material Theme UI Gopher Atom Material Icons Toml Chinese (Simplified) Language Pack 中文包，编译器官方切换中文，不太建议使用，但是我这种英语垃圾的除外。 ","date":"2020-12-24","objectID":"/05-goland-plugins/:2:2","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"工具 ","date":"2020-12-24","objectID":"/05-goland-plugins/:2:3","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"Translation 翻译 GitToolBox git管理 Grep Console 日志上色 .ignore git的.ignore生成 ","date":"2020-12-24","objectID":"/05-goland-plugins/:2:4","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"按优先级划分 具体还是按照自己的需求的情况排序 IdeaVim AceJump + IdeaVim-EasyMotion + IdeaExtention Material Theme UI Key Promoter X Translation GitToolBox Grep Console .ignore Gopher Atom Material Icons Toml Chinese (Simplified) Language Pack","date":"2020-12-24","objectID":"/05-goland-plugins/:3:0","tags":["tools"],"title":"【goland】我的Goland常用的插件记录","uri":"/05-goland-plugins/"},{"categories":["tools"],"content":"powershell美化的介绍.","date":"2020-12-24","objectID":"/04-powershell-up/","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"简述 公司开发使用的windows，平常主要使用的安装zsh的wsl，真香。那么偶尔也需要使用到cmd或者powershell，cmd基本处于放弃的情况，极其的不好用。那么powershell呢？和zsh比还有很大的差距。今天就介绍一下怎么优化你的powershell。 ","date":"2020-12-24","objectID":"/04-powershell-up/:1:0","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"怎么优化powershell？ ","date":"2020-12-24","objectID":"/04-powershell-up/:2:0","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"powershell替代软件 Windows Terminal需要在MS store里面下载 ","date":"2020-12-24","objectID":"/04-powershell-up/:2:1","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"Windows Terminal优化 主题配置 使用oh-my-post主题插件 ","date":"2020-12-24","objectID":"/04-powershell-up/:2:2","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"oh-my-post主题 ​ Mac/Linux下有oh-my-zsh主题，终于，Windows Terminal的PowerShell也有oh-my-posh主题了。oh-my-posh 是一个强大的powerline主题，类似于 Linux下的 oh-my-zsh 。 github地址：github-主题官网 oh-my-post官网：官网 ","date":"2020-12-24","objectID":"/04-powershell-up/:2:3","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"开始 ","date":"2020-12-24","objectID":"/04-powershell-up/:3:0","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"主题安装方法 查看策略组的执行权限 首先，我们需要查看当前的权限，以便后续正常安装，以管理员权限打开的powershell中这么执行指令： Get-ExecutionPolicy -List 此时，我们需要输入以下命令，将CurrentUser的ExecutionPolicy(执行权限)从原来的Undefined更改成RemoteSigned，需要输入命令： Set-ExecutionPolicy RemoteSigned -Scope CurrentUser 按提示输入Y即可，后面所有的提示都是输入Y。 接下来，你需要使用PowerShell Gallery 来安装 oh-my-posh. Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser 都安装好之后，还需要更新配置文件$PROFILE，类似于Linux Bash的.bashrc, 这是全局修改，而不是临时的设置喔~ 输入: $PROFILE 继续输入： if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE 在打开的文件中添加： Import-Module posh-git Import-Module oh-my-posh Set-Theme Honukai 保存后关闭记事本。 其中Set-Theme Honukai是设置主题的，其他可选主题有 Agnoster、Avit、Darkblood、Fish、Honukai、Paradox、Sorin、tehrob，可自行选择。 最后更新配置: C:\\Users\\test\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 Copy 上面的Kuan是你的电脑的用户名，不要照抄。也即前面运行$PROFILE命令后的结果。 重启powershell后会发现已经生效。 提示一个小坑，window安装主题的话，会发现进入带git的目录比较慢的情况，自己研究一下怎么提高速度，练练自己解决问题的能力。 ","date":"2020-12-24","objectID":"/04-powershell-up/:3:1","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["tools"],"content":"总结 ​ 有没有感觉美观了很多，你的powershell变的与众不同。vscode的终端，idea的终端，goland的终端也同样被优化了。赞。详细文档看github官方介绍，可以研究研究怎么自定义主题。 ~ 最后，文件大小原因，不太喜欢插图，请见谅。 ","date":"2020-12-24","objectID":"/04-powershell-up/:4:0","tags":["tools"],"title":"【powershell】Windows powershell环境美化，工具达人必看篇","uri":"/04-powershell-up/"},{"categories":["go"],"content":"简述 之前介绍了Go如何产生coredump，也发现了gdb无法分析Go生成的coredump文件，今天来一起学习一下，Go语言的调试利器 dlv 如何分析coredump。 ","date":"2020-12-24","objectID":"/11-go-dlv-use/:1:0","tags":["go"],"title":"【Go】Go语言的调试利器 dlv debug","uri":"/11-go-dlv-use/"},{"categories":["go"],"content":"开始 ","date":"2020-12-24","objectID":"/11-go-dlv-use/:2:0","tags":["go"],"title":"【Go】Go语言的调试利器 dlv debug","uri":"/11-go-dlv-use/"},{"categories":["go"],"content":"环境安装 Linux环境安装： 方法一: go get github.com/go-delve/delve/cmd/dlv 注意：如果在go mod的模式下使用 Go，则必须在模块目录之外执行此命令，否则 Delve 将作为依赖项添加到项目中。 方法二: 确保$GOPATH设置： $ git clone https://github.com/go-delve/delve.git $GOPATH/src/github.com/go-delve/delve $ cd $GOPATH/src/github.com/go-delve/delve $ make install 推荐使用第一种的方法。 ","date":"2020-12-24","objectID":"/11-go-dlv-use/:2:1","tags":["go"],"title":"【Go】Go语言的调试利器 dlv debug","uri":"/11-go-dlv-use/"},{"categories":["go"],"content":"分析coredump Demo package main import \"fmt\" func main() { a := 10 for i := 1; i \u003c= 10; i++ { fmt.Println(a/(10-i)) } } gdb查看，发现查不出什么问题来。 $ gdb main core.main.4744 GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u003chttp://gnu.org/licenses/gpl.html\u003e This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-redhat-linux-gnu\". For bug reporting instructions, please see: \u003chttp://www.gnu.org/software/gdb/bugs/\u003e... Reading symbols from /root/main/main...done. [New LWP 4744] [New LWP 4748] [New LWP 4746] [New LWP 4745] [New LWP 4747] Core was generated by `./main'. Program terminated with signal 6, Aborted. #0 runtime.raise () at /usr/local/go/src/runtime/sys_linux_amd64.s:165 165 RET warning: File \"/usr/local/go/src/runtime/runtime-gdb.py\" auto-loading has been declined by your `auto-load safe-path' set to \"$debugdir:$datadir/auto-load:/usr/bin/mono-gdb.py\". To enable execution of this file add add-auto-load-safe-path /usr/local/go/src/runtime/runtime-gdb.py line to your configuration file \"/root/.gdbinit\". To completely disable this security protection add set auto-load safe-path / line to your configuration file \"/root/.gdbinit\". For more information about this security protection see the \"Auto-loading safe path\" section in the GDB manual. E.g., run from the shell: info \"(gdb)Auto-loading safe path\" (gdb) bt full #0 runtime.raise () at /usr/local/go/src/runtime/sys_linux_amd64.s:165 No locals. #1 0x000000000044637d in runtime.dieFromSignal (sig=6) at /usr/local/go/src/runtime/signal_unix.go:776 No locals. #2 0x0000000000446891 in runtime.sigfwdgo (sig=6, info=0xc000009bf0, ctx=0xc000009ac0, ~r3=\u003coptimized out\u003e) at /usr/local/go/src/runtime/signal_unix.go:990 fwdFn = \u003coptimized out\u003e flags = \u003coptimized out\u003e g = \u003coptimized out\u003e #3 0x0000000000445034 in runtime.sigtrampgo (sig=6, info=0xc000009bf0, ctx=0xc000009ac0) at /usr/local/go/src/runtime/signal_unix.go:428 setStack = \u003coptimized out\u003e gsignalStack = \u003coptimized out\u003e g = \u003coptimized out\u003e #4 0x0000000000464da3 in runtime.sigtramp () at /usr/local/go/src/runtime/sys_linux_amd64.s:409 No locals. #5 0x0000000000464ea0 in ?? () No locals. #6 0x0000000000000007 in ?? () No symbol table info available. #7 0x0000000000000000 in ?? () ---Type \u003creturn\u003e to continue, or q \u003creturn\u003e to quit--- No symbol table info available. 使用dlv分析 // dlv core {运行文件} {coredump文件} $ dlv core main core.main.4744 Type 'help' for list of commands. (dlv) 查看所有的goroutines (dlv) goroutines * Goroutine 1 - User: ./main.go:8 main.main (0x49915a) (thread 4744) Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:307 runtime.gopark (0x434e85) Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:307 runtime.gopark (0x434e85) Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:307 runtime.gopark (0x434e85) Goroutine 17 - User: /usr/local/go/src/runtime/mfinal.go:161 runtime.runfinq (0x416340) [5 goroutines] 选择异常的goroutines并查看 (dlv) goroutine 1 Switched from 1 to 1 (thread 4744) (dlv) bt 0 0x0000000000464a01 in runtime.raise at /usr/local/go/src/runtime/sys_linux_amd64.s:165 1 0x000000000044637d in runtime.dieFromSignal at /usr/local/go/src/runtime/signal_unix.go:776 2 0x0000000000446891 in runtime.sigfwdgo at /usr/local/go/src/runtime/signal_unix.go:990 3 0x0000000000445034 in runtime.sigtrampgo at /usr/local/go/src/runtime/signal_unix.go:428 4 0x0000000000464da3 in runtime.sigtramp at /usr/local/go/src/runtime/sys_linux_amd64.s:409 5 0x0000000000464ea0 in runtime.sigreturn at /usr/local/go/src/runtime/sys_linux_amd64.s:501 6 0x000000000043254b in runtime.crash at /usr/local/go/src/runtime/signal_unix.go:868 7 0x000000000043254b in runtime.fatalpanic at /usr/local/go/src/runtime/panic.go:1216 8 0x0000000000431e85 in runtime.gopanic at /usr/local/go/src/runtime/panic.go:1064 9 0x0000","date":"2020-12-24","objectID":"/11-go-dlv-use/:2:2","tags":["go"],"title":"【Go】Go语言的调试利器 dlv debug","uri":"/11-go-dlv-use/"},{"categories":["go"],"content":"总结 dlv不仅仅只是可以分析coredump这边简单的功能，还有非常强大的使用方式，时间原因，先简单的写，后续扩展怎么使用dlv调试。 ","date":"2020-12-24","objectID":"/11-go-dlv-use/:3:0","tags":["go"],"title":"【Go】Go语言的调试利器 dlv debug","uri":"/11-go-dlv-use/"},{"categories":["go"],"content":"简单的介绍Go语言如何产生coredump的文件。","date":"2020-12-23","objectID":"/10-go-crash-gen/","tags":["go"],"title":"【Go】Go语言实现产生coredump文件","uri":"/10-go-crash-gen/"},{"categories":["go"],"content":"简述 介绍Go语言生成coredump文件的方式和方法。 ","date":"2020-12-23","objectID":"/10-go-crash-gen/:1:0","tags":["go"],"title":"【Go】Go语言实现产生coredump文件","uri":"/10-go-crash-gen/"},{"categories":["go"],"content":"开始 ​ 之前的文章有谈过，centos7环境如何配置coredump文件的产生，也写了一个c语言的demo测试。今天来说说Go语言也可以生成coredump文件。来看看Go语言如何生成coredump吧。 ","date":"2020-12-23","objectID":"/10-go-crash-gen/:2:0","tags":["go"],"title":"【Go】Go语言实现产生coredump文件","uri":"/10-go-crash-gen/"},{"categories":["go"],"content":"测试demo package main import \"fmt\" func main() { a := 10 for i := 1; i \u003c= 10; i++ { fmt.Println(a/(10-i)) } } go build -o main ./main测试 ","date":"2020-12-23","objectID":"/10-go-crash-gen/:2:1","tags":["go"],"title":"【Go】Go语言实现产生coredump文件","uri":"/10-go-crash-gen/"},{"categories":["go"],"content":"配置Go产生coredump文件 GOTRACEBACK=none :只输出panic异常信息 GOTRACEBACK=single:只输出被认为引发panic异常的那个goroutine的相关信息 GOTRACEBACK=all:输出所有goroutines的相关信息，除去与go runtime相关的stack frames. GOTRACEBACK=system:输出所有goroutines的相关信息，包括与go runtime相关的stack frames,从而得知哪些goroutine是go runtime启动运行的 GOTRACEBACK=crash:与system的唯一区别是crash会生成coredump文件 这边使用最后一个配置的方式 GOTRACEBACK=crash 临时配置GOTRACEBACK=crash 永久配置echo GOTRACEBACK=crash ~/.zshrc或者 echo GOTRACEBACK=crash /etc/profile ","date":"2020-12-23","objectID":"/10-go-crash-gen/:2:2","tags":["go"],"title":"【Go】Go语言实现产生coredump文件","uri":"/10-go-crash-gen/"},{"categories":["go"],"content":"运行文件 ./main 生成coredump $ ./main 1 1 1 1 2 2 3 5 10 panic: runtime error: integer divide by zero goroutine 1 [running]: panic(0x4a88e0, 0x54cc60) /usr/local/go/src/runtime/panic.go:1064 +0x545 fp=0xc000060f00 sp=0xc000060e38 pc=0x431e85 runtime.panicdivide() /usr/local/go/src/runtime/panic.go:191 +0x5b fp=0xc000060f20 sp=0xc000060f00 pc=0x43059b main.main() /root/main/main.go:8 +0xda fp=0xc000060f88 sp=0xc000060f20 pc=0x49915a runtime.main() /usr/local/go/src/runtime/proc.go:204 +0x209 fp=0xc000060fe0 sp=0xc000060f88 pc=0x434a89 runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1374 +0x1 fp=0xc000060fe8 sp=0xc000060fe0 pc=0x463201 goroutine 2 [force gc (idle)]: runtime.gopark(0x4c4dd8, 0x553e20, 0x1411, 0x1) /usr/local/go/src/runtime/proc.go:306 +0xe5 fp=0xc00002cfb0 sp=0xc00002cf90 pc=0x434e85 runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:312 runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:255 +0xc5 fp=0xc00002cfe0 sp=0xc00002cfb0 pc=0x434d25 runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1374 +0x1 fp=0xc00002cfe8 sp=0xc00002cfe0 pc=0x463201 created by runtime.init.6 /usr/local/go/src/runtime/proc.go:243 +0x35 goroutine 3 [GC sweep wait]: runtime.gopark(0x4c4dd8, 0x553f20, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:306 +0xe5 fp=0xc00002d7a8 sp=0xc00002d788 pc=0x434e85 runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:312 runtime.bgsweep(0xc00004a000) /usr/local/go/src/runtime/mgcsweep.go:163 +0x9e fp=0xc00002d7d8 sp=0xc00002d7a8 pc=0x42145e runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1374 +0x1 fp=0xc00002d7e0 sp=0xc00002d7d8 pc=0x463201 created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:217 +0x5c goroutine 4 [GC scavenge wait]: runtime.gopark(0x4c4dd8, 0x553fc0, 0x140d, 0x1) /usr/local/go/src/runtime/proc.go:306 +0xe5 fp=0xc00002df78 sp=0xc00002df58 pc=0x434e85 runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:312 runtime.bgscavenge(0xc00004a000) /usr/local/go/src/runtime/mgcscavenge.go:265 +0xd2 fp=0xc00002dfd8 sp=0xc00002df78 pc=0x41f492 runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1374 +0x1 fp=0xc00002dfe0 sp=0xc00002dfd8 pc=0x463201 created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:218 +0x7e goroutine 5 [finalizer wait]: runtime.gopark(0x4c4dd8, 0x583368, 0x4a1410, 0x1) /usr/local/go/src/runtime/proc.go:306 +0xe5 fp=0xc00002c758 sp=0xc00002c738 pc=0x434e85 runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:312 runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:175 +0xa9 fp=0xc00002c7e0 sp=0xc00002c758 pc=0x4163e9 runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1374 +0x1 fp=0xc00002c7e8 sp=0xc00002c7e0 pc=0x463201 created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x65 [1] 4665 abort (core dumped) ./main -rw------- 1 root root 101M Dec 23 15:05 core.main.4665 ","date":"2020-12-23","objectID":"/10-go-crash-gen/:2:3","tags":["go"],"title":"【Go】Go语言实现产生coredump文件","uri":"/10-go-crash-gen/"},{"categories":["go"],"content":"总结 描述Go生成coredump的方法，和写demo实现，本来尝试使用gdb分析coredump文件，发现看不出堆栈的信息。后续文章分析使用dlv分析go的coredump。 ","date":"2020-12-23","objectID":"/10-go-crash-gen/:3:0","tags":["go"],"title":"【Go】Go语言实现产生coredump文件","uri":"/10-go-crash-gen/"},{"categories":["编程"],"content":"介绍一下centos7环境怎么开启coredump文件转储文件.","date":"2020-12-22","objectID":"/08-centos-coredump/","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"简介 ​ 开发的环境生成coredump文件是非常有必要的，主要用于处理一些非必现问题，看下异常的堆栈可以对问题进行相对精确的分析。如果没有coredump文件的情况如果日志不足的情况，非常难以定位。 ","date":"2020-12-22","objectID":"/08-centos-coredump/:1:0","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"开始 ","date":"2020-12-22","objectID":"/08-centos-coredump/:2:0","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"如何生成coredump? ","date":"2020-12-22","objectID":"/08-centos-coredump/:3:0","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"限制生产的大小 未配置的情况一般是 0，0是无法产生coredump文件 $ ulimit -c 0 限制大小调整，直接调整为不限制的情况 $ ulimit -c unlimited $ ulimit -c unlimited 扩展 临时 ：ulimit -c unlimited // core文件大小不限制 永久 ：echo \"ulimit -c unlimited\" \u003e\u003e ~/.bashrc echo 'ulimit -c unlimited' \u003e\u003e /etc/profile ","date":"2020-12-22","objectID":"/08-centos-coredump/:3:1","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"查看coredump文件 查看coredump文件生成路径 $ cat /proc/sys/kernel/core_pattern core 测试建议设置 $ echo core.%e.%p\u003e/proc/sys/kernel/core_pattern $ cat /proc/sys/kernel/core_pattern core.%e.%p 生产环境建议设置固定目录，务必要手动创建coredump目录 $ echo /tmp/cores/core.%e.%p\u003e/proc/sys/kernel/core_pattern $ cat /proc/sys/kernel/core_pattern /tmp/cores/core.%e.%p ","date":"2020-12-22","objectID":"/08-centos-coredump/:3:2","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"demo测试 使用c语言的demo vim main.c #include \u003cstdio.h\u003e int main() { int a = 1 / 0; } $ gcc main.c -o main $ ./main [1] 1942 floating point exception (core dumped) ./main cd /tmp/cores $ ll total 104K -rw------- 1 root root 240K Dec 22 16:04 core.main.1942 测试成功 ","date":"2020-12-22","objectID":"/08-centos-coredump/:4:0","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"总结 简单的描述了centos的环境，如何实现coredump的生成，你也去体验一下吧。 后续会介绍一下 Go 语言如何产生和分析coredump文件。 ","date":"2020-12-22","objectID":"/08-centos-coredump/:5:0","tags":["编程"],"title":"【centos】如何开启coredump文件转储文件","uri":"/08-centos-coredump/"},{"categories":["编程"],"content":"最简单的redis学习环境部署方法.","date":"2020-12-21","objectID":"/07-redis-install/","tags":["编程"],"title":"【redis】最简单的Redis学习环境部署- docker篇","uri":"/07-redis-install/"},{"categories":["编程"],"content":"简介 学习redis和学习编程语言一样，学习之前需要把环境安装好，能实践的学习。今天主要介绍一下，redis的docker学习环境安装方法。 ","date":"2020-12-21","objectID":"/07-redis-install/:1:0","tags":["编程"],"title":"【redis】最简单的Redis学习环境部署- docker篇","uri":"/07-redis-install/"},{"categories":["编程"],"content":"下载redis镜像 拉取 Redis 镜像, 选择 redis:alpine 轻量级镜像版本： docker pull redis:alpine ","date":"2020-12-21","objectID":"/07-redis-install/:2:0","tags":["编程"],"title":"【redis】最简单的Redis学习环境部署- docker篇","uri":"/07-redis-install/"},{"categories":["编程"],"content":"运行容器 docker run -p 6379:6379 --name redis -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/redis/data:/data -d redis:alpine redis-server /etc/redis/redis.conf --appendonly yes 命令说明： -p 6379:6379: 将容器的 6379 端口映射到宿主机的 6379 端口； -v /usr/local/docker/redis/data:/data : 将容器中的 /data 数据存储目录, 挂载到宿主机中 /usr/local/docker/redis/data 目录下； -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf ： 将容器中 /etc/redis/redis.conf 配置文件，挂载到宿主机的 /usr/local/docker/redis/redis.conf 文件上； redis-server --appendonly yes: 在容器执行 redis-server 启动命令，并打开 redis 持久化配置; ","date":"2020-12-21","objectID":"/07-redis-install/:3:0","tags":["编程"],"title":"【redis】最简单的Redis学习环境部署- docker篇","uri":"/07-redis-install/"},{"categories":["编程"],"content":"连接刚刚创建好的容器 docker run -it redis:alpine redis-cli -h 172.17.0.1 是不是ok了，开始你的测试吧 ","date":"2020-12-21","objectID":"/07-redis-install/:4:0","tags":["编程"],"title":"【redis】最简单的Redis学习环境部署- docker篇","uri":"/07-redis-install/"},{"categories":["编程"],"content":"总结 简单介绍redis的docker测试环境的安装过来，快去实践吧。 ","date":"2020-12-21","objectID":"/07-redis-install/:5:0","tags":["编程"],"title":"【redis】最简单的Redis学习环境部署- docker篇","uri":"/07-redis-install/"},{"categories":["编程"],"content":"jaeger: open source, end-to-end distributed tracing Monitor and troubleshoot transactions in complex distributed systems.","date":"2020-12-20","objectID":"/06-docker-all/","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker从入门到干活，看这一篇足矣 Java笔记虾 作者：惨绿少年 ","date":"2020-12-20","objectID":"/06-docker-all/:1:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"转载文章，需要更好的阅读效果可以移步原文 Java笔记虾原文地址 ","date":"2020-12-20","objectID":"/06-docker-all/:2:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"容器简介 ","date":"2020-12-20","objectID":"/06-docker-all/:3:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"什么是 Linux 容器 Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。 容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。 更加详细地来说，请您假定您在开发一个应用。您使用的是一台笔记本电脑，而且您的开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。您正在开发的应用依赖于您当前的配置，还要依赖于某些特定文件。 与此同时，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。 您希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。 因此，您要如何确保应用能够在这些环境中运行和通过质量检测，并且在部署过程中不出现令人头疼的问题，也无需重新编写代码和进行故障修复？答案就是使用容器。 容器可以确保您的应用拥有必需的配置和文件，使得这些应用能够在从开发到测试、再到生产的整个流程中顺利运行，而不出现任何不良问题。这样可以避免危机，做到皆大欢喜。 虽然这只是简化的示例，但在需要很高的可移植性、可配置性和隔离的情况下，我们可以利用 Linux 容器通过很多方式解决难题。 无论基础架构是在企业内部还是在云端，或者混合使用两者，容器都能满足您的需求。 ","date":"2020-12-20","objectID":"/06-docker-all/:3:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"容器不就是虚拟化吗 是，但也不竟然。我们用一种简单方式来思考一下： 虚拟化使得许多操作系统可同时在单个系统上运行。 容器则可共享同一个操作系统内核，将应用进程与系统其他部分隔离开。 图 - 普通虚拟化技术和Docker的对比 这意味着什么？首先，让多个操作系统在单个虚拟机监控程序上运行以实现虚拟化，并不能达成和使用容器同等的轻量级效果。 事实上，在仅拥有容量有限的有限资源时，您需要能够可以进行密集部署的轻量级应用。 Linux 容器可从单个操作系统运行，在所有容器中共享该操作系统，因此应用和服务能够保持轻量级，并行快速运行。 ","date":"2020-12-20","objectID":"/06-docker-all/:3:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"容器发展简史 我们现在称为容器技术的概念最初出现在 2000 年，当时称为 FreeBSD jail，这种技术可将 FreeBSD 系统分区为多个子系统（也称为 Jail）。 Jail 是作为安全环境而开发的，系统管理员可与企业内部或外部的多个用户共享这些 Jail。 Jail 的目的是让进程在经过修改的 chroot 环境中创建，而不会脱离和影响整个系统 — 在 chroot 环境中，对文件系统、网络和用户的访问都实现了虚拟化。 尽管 Jail 在实施方面存在局限性，但最终人们找到了脱离这种隔离环境的方法。 但这个概念非常有吸引力。 2001 年，通过 Jacques Gélinas 的 VServer 项目，隔离环境的实施进入了 Linux 领域。 正如 Gélinas 所说，这项工作的目的是“在高度独立且安全的单一环境中运行多个通用 Linux 服务器 [sic]。” 在完成了这项针对 Linux 中多个受控制用户空间的基础性工作后，Linux 容器开始逐渐成形并最终发展成了现在的模样。 ","date":"2020-12-20","objectID":"/06-docker-all/:3:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"什么是 Docker？ “Docker” 一词指代多种事物，包括开源社区项目、开源项目使用的工具、主导支持此类项目的公司 Docker Inc. 以及该公司官方支持的工具。技术产品和公司使用同一名称，的确让人有点困惑。 我们来简单说明一下： 🎍 IT 软件中所说的 “Docker” ，是指容器化技术，用于支持创建和使用 Linux 容器。 🎍 开源 Docker 社区致力于改进这类技术，并免费提供给所有用户，使之获益。 🎍 Docker Inc. 公司凭借 Docker 社区产品起家，它主要负责提升社区版本的安全性，并将改进后的版本与更广泛的技术社区分享。此外，它还专门对这些技术产品进行完善和安全固化，以服务于企业客户。 借助 Docker ，您可将容器当做重量轻、模块化的虚拟机使用。同时，您还将获得高度的灵活性，从而实现对容器的高效创建、部署及复制，并能将其从一个环境顺利迁移至另一个环境。 ","date":"2020-12-20","objectID":"/06-docker-all/:4:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker 如何工作？ Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。 这种独立性正是采用容器的目的所在；它可以独立运行多种进程、多个应用程序，更加充分地发挥基础设施的作用，同时保持各个独立系统的安全性。 容器工具（包括 Docker）可提供基于镜像的部署模式。这使得它能够轻松跨多种环境，与其依赖程序共享应用或服务组。Docker 还可在这一容器环境中自动部署应用程序（或者合并多种流程，以构建单个应用程序）。 此外，由于这些工具基于 Linux 容器构建，使得 Docker 既易于使用，又别具一格 —— 它可为用户提供前所未有的高度应用程访问权限、快速部署以及版本控制和分发能力。 ","date":"2020-12-20","objectID":"/06-docker-all/:4:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker 技术是否与传统的 Linux 容器相同？ 否。Docker 技术最初是基于 LXC 技术构建（大多数人都会将这一技术与“传统的” Linux 容器联系在一起），但后来它逐渐摆脱了对这种技术的依赖。 就轻量级 虚拟化 这一功能来看，LXC 非常有用，但它无法提供出色的开发人员或用户体验。除了运行容器之外，Docker 技术还具备其他多项功能，包括简化用于构建容器、传输镜像以及控制镜像版本的流程。 传统的 Linux 容器使用 init 系统来管理多种进程。这意味着，所有应用程序都作为一个整体运行。与此相反，Docker 技术鼓励应用程序各自独立运行其进程，并提供相应工具以实现这一功能。这种精细化运作模式自有其优势。 ","date":"2020-12-20","objectID":"/06-docker-all/:4:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"docker的目标 docker的主要目标是\"Build,Ship and Run any App,Angwhere\",构建，运输，处处运行 **构建：**做一个docker镜像 **运输：**docker pull **运行：**启动一个容器 每一个容器，他都有自己的文件系统rootfs. ","date":"2020-12-20","objectID":"/06-docker-all/:4:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"安装Docker 环境说明 # 需要两台几点进行安装 [root@docker01 ~]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) [root@docker01 ~]# uname -r 3.10.0-327.el7.x86_64 [root@docker01 ~]# hostname -I 10.0.0.100 172.16.1.100 [root@docker02 ~]# hostname -I 10.0.0.101 172.16.1.101 在两个节点上都进行操作 wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo sed -i 's#download.docker.com#mirrors.ustc.edu.cn/docker-ce#g' /etc/yum.repos.d/docker-ce.repo yum install docker-ce -y 修改在docker01配置： # 修改启动文件，监听远程端口 vim /usr/lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://10.0.0.100:2375 systemctl daemon-reload systemctl enable docker.service systemctl restart docker.service # ps -ef检查进行，是否启动 在docker02测试 [root@docker02 ~]# docker -H 10.0.0.100 info Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 17.12.0-ce Storage Driver: devicemapper ··· ","date":"2020-12-20","objectID":"/06-docker-all/:5:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker基础命令操作 查看docker相关信息 [root@docker01 ~]# docker version Client: Version: 17.12.0-ce API version: 1.35 Go version: go1.9.2 Git commit: c97c6d6 Built: Wed Dec 27 20:10:14 2017 OS/Arch: linux/amd64 Server: Engine: Version: 17.12.0-ce API version: 1.35 (minimum version 1.12) Go version: go1.9.2 Git commit: c97c6d6 Built: Wed Dec 27 20:12:46 2017 OS/Arch: linux/amd64 Experimental: false 配置docker镜像加速 vi /etc/docker/daemon.json { \"registry-mirrors\": [\"https://registry.docker-cn.com\"] } ","date":"2020-12-20","objectID":"/06-docker-all/:5:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"启动第一个容器 [root@docker01 ~]# docker run -d -p 80:80 nginx Unable to find image 'nginx:latest' locally latest: Pulling from library/nginx e7bb522d92ff: Pull complete 6edc05228666: Pull complete cd866a17e81f: Pull complete Digest: sha256:285b49d42c703fdf257d1e2422765c4ba9d3e37768d6ea83d7fe2043dad6e63d Status: Downloaded newer image for nginx:latest 8d8f81da12b5c10af6ba1a5d07f4abc041cb95b01f3d632c3d638922800b0b4d # 容器启动后，在浏览器进行访问测试 参数说明 ","date":"2020-12-20","objectID":"/06-docker-all/:5:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker镜像生命周期 ","date":"2020-12-20","objectID":"/06-docker-all/:5:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker镜像相关操作 ","date":"2020-12-20","objectID":"/06-docker-all/:6:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"搜索官方仓库镜像 [root@docker01 ~]# docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 3992 [OK] ansible/centos7-ansible Ansible on Centos7 105 [OK] 列表说明 ","date":"2020-12-20","objectID":"/06-docker-all/:6:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"获取镜像 根据镜像名称拉取镜像 [root@docker01 ~]# docker pull centos Using default tag: latest latest: Pulling from library/centos af4b0a2388c6: Downloading 34.65MB/73.67MB 查看当前主机镜像列表 [root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZE centos latest ff426288ea90 3 weeks ago 207MB nginx latest 3f8a4339aadd 5 weeks ago 108MB 拉第三方镜像方法 docker pull index.tenxcloud.com/tenxcloud/httpd ","date":"2020-12-20","objectID":"/06-docker-all/:6:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"导出镜像 [root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZE centos latest ff426288ea90 3 weeks ago 207MB nginx latest 3f8a4339aadd 5 weeks ago 108MB # 导出 [root@docker01 ~]# docker image save centos \u003e docker-centos.tar.gz ","date":"2020-12-20","objectID":"/06-docker-all/:6:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"删除镜像 [root@docker01 ~]# docker image rm centos:latest [root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 3f8a4339aadd 5 weeks ago 108MB ","date":"2020-12-20","objectID":"/06-docker-all/:6:4","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"导入镜像 [root@docker01 ~]# docker image load -i docker-centos.tar.gz e15afa4858b6: Loading layer 215.8MB/215.8MB Loaded image: centos:latest [root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZE centos latest ff426288ea90 3 weeks ago 207MB nginx latest 3f8a4339aadd 5 weeks ago 108MB ","date":"2020-12-20","objectID":"/06-docker-all/:6:5","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"查看镜像的详细信息 [root@docker01 ~]# docker image inspect centos ","date":"2020-12-20","objectID":"/06-docker-all/:6:6","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"容器的日常管理 ","date":"2020-12-20","objectID":"/06-docker-all/:7:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"容器的起/停 最简单的运行一个容器 [root@docker01 ~]# docker run nginx 创建容器，两步走（不常用） [root@docker01 ~]# docker create centos:latest /bin/bash bb7f32368ecf0492adb59e20032ab2e6cf6a563a0e6751e58930ee5f7aaef204 [root@docker01 ~]# docker start stupefied_nobel stupefied_nobel 快速启动容器方法 [root@docker01 ~]# docker run centos:latest /usr/bin/sleep 20; 容器内的第一个进程必须一直处于运行的状态，否则这个容器，就会处于退出状态！ 查看正在运行的容器 [root@docker01 ~]# docker container ls 或 [root@docker01 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8708e93fd767 nginx \"nginx -g 'daemon of…\" 6 seconds ago Up 4 seconds 80/tcp keen_lewin 查看你容器详细信息/ip [root@docker01 ~]# docker container inspect 容器名称/id 查看你所有容器（包括未运行的） [root@docker01 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8708e93fd767 nginx \"nginx -g 'daemon of…\" 4 minutes ago Exited (0) 59 seconds ago keen_lewin f9f3e6af7508 nginx \"nginx -g 'daemon of…\" 5 minutes ago Exited (0) 5 minutes ago optimistic_haibt 8d8f81da12b5 nginx \"nginx -g 'daemon of…\" 3 hours ago Exited (0) 3 hours ago lucid_bohr 停止容器 [root@docker01 ~]# docker stop 容器名称/id 或 [root@docker01 ~]# docker container kill 容器名称/id ","date":"2020-12-20","objectID":"/06-docker-all/:7:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"进入容器方法 启动时进去方法 [root@docker01 ~]# docker run -it #参数：-it 可交互终端 [root@docker01 ~]# docker run -it nginx:latest /bin/bash root@79241093859e:/# 退出/离开容器 ctrl+p \u0026 ctrl+q 启动后进入容器的方法 启动一个docker [root@docker01 ~]# docker run -it centos:latest [root@1bf0f43c4d2f /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 15:47 pts/0 00:00:00 /bin/bash root 13 1 0 15:47 pts/0 00:00:00 ps -ef attach进入容器，使用pts/0 ，会让所用通过此方法进如放入用户看到同样的操作。 [root@docker01 ~]# docker attach 1bf0f43c4d2f [root@1bf0f43c4d2f /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 15:47 pts/0 00:00:00 /bin/bash root 14 1 0 15:49 pts/0 00:00:00 ps -ef 自命名启动一个容器 –name [root@docker01 ~]# docker attach 1bf0f43c4d2f [root@1bf0f43c4d2f /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 15:47 pts/0 00:00:00 /bin/bash root 14 1 0 15:49 pts/0 00:00:00 ps -ef exec 进入容器方法（推荐使用） [root@docker01 ~]# docker exec -it clsn1 /bin/bash [root@b20fa75b4b40 /]# 重新分配一个终端 [root@b20fa75b4b40 /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 16:11 pts/0 00:00:00 /bin/bash root 13 0 0 16:14 pts/1 00:00:00 /bin/bash root 26 13 0 16:14 pts/1 00:00:00 ps -ef ","date":"2020-12-20","objectID":"/06-docker-all/:7:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"删除所有容器 [root@docker01 ~]# docker rm -f `docker ps -a -q` # -f 强制删除 ","date":"2020-12-20","objectID":"/06-docker-all/:7:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"启动时进行端口映射 -p参数端口映射 [root@docker01 ~]# docker run -d -p 8888:80 nginx:latest 287bec5c60263166c03e1fc5b0b8262fe76507be3dfae4ce5cd2ee2d1e8a89a9 不同指定映射方法 随机映射 docker run -P （大P）# 需要镜像支持 ","date":"2020-12-20","objectID":"/06-docker-all/:7:4","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker 数据卷的管理 ","date":"2020-12-20","objectID":"/06-docker-all/:8:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"挂载时创建卷 挂载卷 [root@docker01 ~]# docker run -d -p 80:80 -v /data:/usr/share/nginx/html nginx:latest 079786c1e297b5c5031e7a841160c74e91d4ad06516505043c60dbb78a259d09 容器内站点目录: /usr/share/nginx/html 在宿主机写入数据，查看 [root@docker01 ~]# echo \"http://www.nmtui.com\" \u003e/data/index.html [root@docker01 ~]# curl 10.0.0.100 http://www.nmtui.com 设置共享卷，使用同一个卷启动一个新的容器 [root@docker01 ~]# docker run -d -p 8080:80 -v /data:/usr/share/nginx/html nginx:latest 351f0bd78d273604bd0971b186979aa0f3cbf45247274493d2490527babb4e42 [root@docker01 ~]# curl 10.0.0.100:8080 http://www.nmtui.com 查看卷列表 [root@docker01 ~]# docker volume ls DRIVER VOLUME NAME ","date":"2020-12-20","objectID":"/06-docker-all/:8:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"创建卷后挂载 创建一个卷 [root@docker01 ~]# docker volume create f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521 [root@docker01 ~]# docker volume ls DRIVER VOLUME NAME local f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521 指定卷名 [root@docker01 ~]# docker volume ls DRIVER VOLUME NAME local clsn local f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521 查看卷路径 [root@docker01 ~]# docker volume inspect clsn [ { \"CreatedAt\": \"2018-02-01T00:39:25+08:00\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/clsn/_data\", \"Name\": \"clsn\", \"Options\": {}, \"Scope\": \"local\" } ] 使用卷创建 [root@docker01 ~]# docker run -d -p 9000:80 -v clsn:/usr/share/nginx/html nginx:latest 1434559cff996162da7ce71820ed8f5937fb7c02113bbc84e965845c219d3503 # 宿主机测试 [root@docker01 ~]# echo 'blog.nmtui.com' \u003e/var/lib/docker/volumes/clsn/_data/index.html [root@docker01 ~]# curl 10.0.0.100:9000 blog.nmtui.com 设置卷 [root@docker01 ~]# docker run -d -P --volumes-from 079786c1e297 nginx:latest b54b9c9930b417ab3257c6e4a8280b54fae57043c0b76b9dc60b4788e92369fb 查看使用的端口 [root@docker01 ~]# netstat -lntup Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1400/sshd tcp 0 0 10.0.0.100:2375 0.0.0.0:* LISTEN 26218/dockerd tcp6 0 0 :::9000 :::* LISTEN 32015/docker-proxy tcp6 0 0 :::8080 :::* LISTEN 31853/docker-proxy tcp6 0 0 :::80 :::* LISTEN 31752/docker-proxy tcp6 0 0 :::22 :::* LISTEN 1400/sshd tcp6 0 0 :::32769 :::* LISTEN 32300/docker-proxy [root@docker01 ~]# curl 10.0.0.100:32769 http://www.nmtui.com ","date":"2020-12-20","objectID":"/06-docker-all/:8:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"手动将容器保存为镜像 本次是基于docker官方centos 6.8 镜像创建 官方镜像列表： https://hub.docker.com/explore/ 启动一个centos6.8的镜像 [root@docker01 ~]# docker pull centos:6.8 [root@docker01 ~]# docker run -it -p 1022:22 centos:6.8 /bin/bash # 在容器种安装sshd服务，并修改系统密码 [root@582051b2b92b ~]# yum install openssh-server -y [root@582051b2b92b ~]# echo \"root:123456\" |chpasswd [root@582051b2b92b ~]# /etc/init.d/sshd start 启动完成后镜像ssh连接测试 将容器提交为镜像 [root@docker01 ~]# docker commit brave_mcclintock centos6-ssh 使用新的镜像启动容器 [root@docker01 ~]# docker run -d -p 1122:22 centos6-ssh:latest /usr/sbin/sshd -D 5b8161fda2a9f2c39c196c67e2eb9274977e7723fe51c4f08a0190217ae93094 在容器安装httpd服务 [root@5b8161fda2a9 /]# yum install httpd -y 编写启动脚本脚本 [root@5b8161fda2a9 /]# cat init.sh #!/bin/bash /etc/init.d/httpd start /usr/sbin/sshd -D [root@5b8161fda2a9 /]# chmod +x init.sh # 注意执行权限 再次提交为新的镜像 [root@docker01 ~]# docker commit 5b8161fda2a9 centos6-httpd sha256:705d67a786cac040800b8485cf046fd57b1828b805c515377fc3e9cea3a481c1 启动镜像，做好端口映射。并在浏览器中测试访问 [root@docker01 ~]# docker run -d -p 1222:22 -p 80:80 centos6-httpd /init.sh 46fa6a06644e31701dc019fb3a8c3b6ef008d4c2c10d46662a97664f838d8c2c ","date":"2020-12-20","objectID":"/06-docker-all/:8:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Dockerfile自动构建docker镜像 官方构建dockerffile文件参考 https://github.com/CentOS/CentOS-Dockerfiles ","date":"2020-12-20","objectID":"/06-docker-all/:9:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Dockerfile指令集 dockerfile主要组成部分： 基础镜像信息 FROM centos:6.8 制作镜像操作指令RUN yum insatll openssh-server -y 容器启动时执行指令 CMD [\"/bin/bash\"] dockerfile常用指令： FROM 这个镜像的妈妈是谁？（指定基础镜像） MAINTAINER 告诉别人，谁负责养它？（指定维护者信息，可以没有） RUN 你想让它干啥（在命令前面加上RUN即可） ADD 给它点创业资金（COPY文件，会自动解压） WORKDIR 我是cd,今天刚化了妆（设置当前工作目录） VOLUME 给它一个存放行李的地方（设置卷，挂载主机目录） EXPOSE 它要打开的门是啥（指定对外的端口） CMD 奔跑吧，兄弟！（指定容器启动后的要干的事情） dockerfile其他指令： COPY 复制文件 ENV 环境变量 ENTRYPOINT 容器启动后执行的命令 ","date":"2020-12-20","objectID":"/06-docker-all/:9:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"创建一个Dockerfile 创建第一个Dockerfile文件 # 创建目录 [root@docker01 base]# cd /opt/base # 创建Dcokerfile文件，注意大小写 [root@docker01 base]# vim Dockerfile FROM centos:6.8 RUN yum install openssh-server -y RUN echo \"root:123456\" |chpasswd RUN /etc/init.d/sshd start CMD [\"/usr/sbin/sshd\",\"-D\"] 构建docker镜像 [root@docker01 base]# docker image build -t centos6.8-ssh . -t 为镜像标签打标签 . 表示当前路径 使用自构建的镜像启动 [root@docker01 base]# docker run -d -p 2022:22 centos6.8-ssh-b dc3027d3c15dac881e8e2aeff80724216f3ac725f142daa66484f7cb5d074e7a ","date":"2020-12-20","objectID":"/06-docker-all/:9:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"使用Dcokerfile安装kodexplorer Dockerfile文件内容 FROM centos:6.8 RUN yum install wget unzip php php-gd php-mbstring -y \u0026\u0026 yum clean all # 设置工作目录，之后的操作都在这个目录中 WORKDIR /var/www/html/ RUN wget -c http://static.kodcloud.com/update/download/kodexplorer4.25.zip RUN unzip kodexplorer4.25.zip \u0026\u0026 rm -f kodexplorer4.25.zip RUN chown -R apache.apache . CMD [\"/usr/sbin/apachectl\",\"-D\",\"FOREGROUND\"] 更多的Dockerfile可以参考官方方法。 ","date":"2020-12-20","objectID":"/06-docker-all/:9:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker中的镜像分层 参考文档： http://www.maiziedu.com/wiki/cloud/dockerimage/ Docker 支持通过扩展现有镜像，创建新的镜像。实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。 从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。 ","date":"2020-12-20","objectID":"/06-docker-all/:10:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker 镜像为什么分层 镜像分层最大的一个好处就是共享资源。 比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是不会被修改的，修改只会被限制在单个容器内。这就是容器 Copy-on-Write 特性。 ","date":"2020-12-20","objectID":"/06-docker-all/:10:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"可写的容器层 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 ","date":"2020-12-20","objectID":"/06-docker-all/:10:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"容器层的细节说明 镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。 文件操作的 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。 ","date":"2020-12-20","objectID":"/06-docker-all/:10:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"使用docker运行zabbix-server ","date":"2020-12-20","objectID":"/06-docker-all/:11:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"容器间的互联 在运行zabbix之前务必要了解容器间互联的方法 # 创建一个nginx容器 docker run -d -p 80:80 nginx # 创建容器，做link，并进入容器中 docker run -it --link quirky_brown:web01 centos-ssh /bin/bash # 在容器中访问nginx容器可以ping通 ping web01 命令执行过程 # 启动apache容器 [root@docker01 ~]# docker run -d httpd:2.4 3f1f7fc554720424327286bd2b04aeab1b084a3fb011a785b0deab6a34e56955 ^[[A[root@docker01 docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3f1f7fc55472 httpd:2.4 \"httpd-foreground\" 6 seconds ago Up 5 seconds 80/tcp determined_clarke # 拉取一个busybox 镜像 [root@docker01 ~]# docker pull busybox # 启动容器 [root@docker01 ~]# docker run -it --link determined_clarke:web busybox:latest /bin/sh / # # 使用新的容器访问最初的web容器 / # ping web PING web (172.17.0.2): 56 data bytes 64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.058 ms ^C --- web ping statistics --- 1 packets transmitted, 1 packets received, 0% packet loss round-trip min/avg/max = 0.058/0.058/0.058 ms ","date":"2020-12-20","objectID":"/06-docker-all/:11:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"启动zabbix容器 1、启动一个mysql的容器 docker run --name mysql-server -t \\ -e MYSQL_DATABASE=\"zabbix\" \\ -e MYSQL_USER=\"zabbix\" \\ -e MYSQL_PASSWORD=\"zabbix_pwd\" \\ -e MYSQL_ROOT_PASSWORD=\"root_pwd\" \\ -d mysql:5.7 \\ --character-set-server=utf8 --collation-server=utf8_bin 2、启动java-gateway容器监控java服务 docker run --name zabbix-java-gateway -t \\ -d zabbix/zabbix-java-gateway:latest 3、启动zabbix-mysql容器使用link连接mysql与java-gateway。 docker run --name zabbix-server-mysql -t \\ -e DB_SERVER_HOST=\"mysql-server\" \\ -e MYSQL_DATABASE=\"zabbix\" \\ -e MYSQL_USER=\"zabbix\" \\ -e MYSQL_PASSWORD=\"zabbix_pwd\" \\ -e MYSQL_ROOT_PASSWORD=\"root_pwd\" \\ -e ZBX_JAVAGATEWAY=\"zabbix-java-gateway\" \\ --link mysql-server:mysql \\ --link zabbix-java-gateway:zabbix-java-gateway \\ -p 10051:10051 \\ -d zabbix/zabbix-server-mysql:latest 4、启动zabbix web显示，使用link连接zabbix-mysql与mysql。 docker run --name zabbix-web-nginx-mysql -t \\ -e DB_SERVER_HOST=\"mysql-server\" \\ -e MYSQL_DATABASE=\"zabbix\" \\ -e MYSQL_USER=\"zabbix\" \\ -e MYSQL_PASSWORD=\"zabbix_pwd\" \\ -e MYSQL_ROOT_PASSWORD=\"root_pwd\" \\ --link mysql-server:mysql \\ --link zabbix-server-mysql:zabbix-server \\ -p 80:80 \\ -d zabbix/zabbix-web-nginx-mysql:latest ","date":"2020-12-20","objectID":"/06-docker-all/:11:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"关于zabbix API 关于zabbix API可以参考官方文档： https://www.zabbix.com/documentation/3.4/zh/manual/api 1、获取token方法 # 获取token [root@docker02 ~]# curl -s -X POST -H 'Content-Type:application/json' -d ' { \"jsonrpc\": \"2.0\", \"method\": \"user.login\", \"params\": { \"user\": \"Admin\", \"password\": \"zabbix\" }, \"id\": 1 }' http://10.0.0.100/api_jsonrpc.php {\"jsonrpc\":\"2.0\",\"result\":\"d3be707f9e866ec5d0d1c242292cbebd\",\"id\":1} ","date":"2020-12-20","objectID":"/06-docker-all/:11:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"docker 仓库（registry） ","date":"2020-12-20","objectID":"/06-docker-all/:12:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"创建一个普通仓库 1、创建仓库 docker run -d -p 5000:5000 --restart=always --name registry -v /opt/myregistry:/var/lib/registry registry 2、修改配置文件，使之支持http [root@docker01 ~]# cat /etc/docker/daemon.json { \"registry-mirrors\": [\"https://registry.docker-cn.com\"], \"insecure-registries\": [\"10.0.0.100:5000\"] } 重启docker让修改生效 [root@docker01 ~]# systemctl restart docker.service 3、修改镜像标签 [root@docker01 ~]# docker tag busybox:latest 10.0.0.100:5000/clsn/busybox:1.0 [root@docker01 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos6-ssh latest 3c2b1e57a0f5 18 hours ago 393MB httpd 2.4 2e202f453940 6 days ago 179MB 10.0.0.100:5000/clsn/busybox 1.0 5b0d59026729 8 days ago 1.15MB 4、将新打标签的镜像上传镜像到仓库 [root@docker01 ~]# docker push 10.0.0.100:5000/clsn/busybox ","date":"2020-12-20","objectID":"/06-docker-all/:12:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"带basic认证的仓库 1、安装加密工具 [root@docker01 clsn]# yum install httpd-tools -y 2、设置认证密码 mkdir /opt/registry-var/auth/ -p htpasswd -Bbn clsn 123456 \u003e /opt/registry-var/auth/htpasswd 3、启动容器，在启动时传入认证参数 docker run -d -p 5000:5000 -v /opt/registry-var/auth/:/auth/ -e \"REGISTRY_AUTH=htpasswd\" -e \"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\" -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd registry 4、使用验证用户测试 # 登陆用户 [root@docker01 ~]# docker login 10.0.0.100:5000 Username: clsn Password: 123456 Login Succeeded # 推送镜像到仓库 [root@docker01 ~]# docker push 10.0.0.100:5000/clsn/busybox The push refers to repository [10.0.0.100:5000/clsn/busybox] 4febd3792a1f: Pushed 1.0: digest: sha256:4cee1979ba0bf7db9fc5d28fb7b798ca69ae95a47c5fecf46327720df4ff352d size: 527 #认证文件的保存位置 [root@docker01 ~]# cat .docker/config.json { \"auths\": { \"10.0.0.100:5000\": { \"auth\": \"Y2xzbjoxMjM0NTY=\" }, \"https://index.docker.io/v1/\": { \"auth\": \"Y2xzbjpIenNAMTk5Ng==\" } }, \"HttpHeaders\": { \"User-Agent\": \"Docker-Client/17.12.0-ce (linux)\" } } 至此，一个简单的docker镜像仓库搭建完成 ","date":"2020-12-20","objectID":"/06-docker-all/:12:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"docker-compose编排工具 ","date":"2020-12-20","objectID":"/06-docker-all/:13:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"安装docker-compose 安装docker-compose # 下载pip软件 yum install -y python2-pip # 下载 docker-compose pip install docker-compose 国内开启pip 下载加速： http://mirrors.aliyun.com/help/pypi mkdir ~/.pip/ cat \u003e ~/.pip/pip.conf \u003c\u003c'EOF' [global] index-url = https://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com EOF ","date":"2020-12-20","objectID":"/06-docker-all/:13:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"编排启动镜像 1、创建文件目录 [root@docker01 ~]# mkdir /opt/my_wordpress/ [root@docker01 ~]# cd /opt/my_wordpress/ 2、编写编排文件 [root@docker01 my_wordpress]# vim docker-compose.yml version: '3' services: db: image: mysql:5.7 volumes: - /data/db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /data/web_data:/var/www/html ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress 3、启动 [root@docker01 my_wordpress]# docker-compose up #启动方法：docker-compose up #后台启动方法：docker-compose up -d 4、浏览器上访问http://10.0.0.100:8000 进行wordpress的安装即可 ","date":"2020-12-20","objectID":"/06-docker-all/:13:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"haproxy代理后端docker容器 1、修改编排脚本 [root@docker01 my_wordpress]# cat docker-compose.yml version: '3' services: db: image: mysql:5.7 volumes: - /data/db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /data/web_data:/var/www/html ports: - \"80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress 2、同时启动两台wordpress [root@docker01 my_wordpress]# docker-compose scale wordpress=2 WARNING: The scale command is deprecated. Use the up command with the --scale flag instead. Starting mywordpress_wordpress_1 ... done Creating mywordpress_wordpress_2 ... done 3、安装haproxy [root@docker01 ~]# yum install haproxy -y 4、修改haproxy配置文件 关于配置文件的详细说明，参考： https://www.cnblogs.com/MacoLee/p/5853413.html [root@docker01 ~]#cp /etc/haproxy/haproxy.cfg{,.bak} [root@docker01 ~]# vim /etc/haproxy/haproxy.cfg global log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon stats socket /var/lib/haproxy/stats level admin #支持命令行控制 defaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 3000 listen stats mode http bind 0.0.0.0:8888 stats enable stats uri /haproxy-status stats auth admin:123456 frontend frontend_www_example_com bind 10.0.0.100:8000 mode http option httplog log global default_backend backend_www_example_com backend backend_www_example_com option forwardfor header X-REAL-IP option httpchk HEAD / HTTP/1.0 balance roundrobin server web-node1 10.0.0.100:32768 check inter 2000 rise 30 fall 15 server web-node2 10.0.0.100:32769 check inter 2000 rise 30 fall 15 5、启动haproxy systemctl start haproxy systemctl enable haproxy 6、使用浏览器访问hapeoxy监听的8000端口可以看到负载的情况 7、使用浏览器访问 http://10.0.0.100:8888/haproxy-status 可以看到后端节点的监控状况， ","date":"2020-12-20","objectID":"/06-docker-all/:13:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"安装socat 直接操作socket控制haproxy 1、安装软件 yum install socat.x86_64 -y 2、查看帮助 [root@docker01 web_data]# echo \"help\"|socat stdio /var/lib/haproxy/stats 3、下线后端节点 echo \"disable server backend_www_example_com/web-node2\"|socat stdio /var/lib/haproxy/stats 4、上线后端节点 echo \"enable server backend_www_example_com/web-node3\"|socat stdio /var/lib/haproxy/stats 5、编写php测试页，放到/data/web_data下，在浏览器中访问可以查看当前的节点 [root@docker01 web_data]# vim check.php \u003chtml\u003e \u003chead\u003e \u003ctitle\u003ePHP测试\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c?php echo '\u003cp\u003eHello World \u003c/p\u003e'; ?\u003e \u003c?php echo \"访问的服务器地址是:\".\"\u003cfontcolor=red\u003e\".$_SERVER['SERVER_ADDR'].\"\u003c/font\u003e\".\"\u003cbr\u003e\"; echo\"访问的服务器域名是:\".\"\u003cfontcolor=red\u003e\".$_SERVER['SERVER_NAME'].\"\u003c/font\u003e\".\"\u003cbr\u003e\"; ?\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-12-20","objectID":"/06-docker-all/:13:4","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"重启docker服务，容器全部退出的解决办法 ","date":"2020-12-20","objectID":"/06-docker-all/:14:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"在启动是指定自动重启 docker run --restart=always ","date":"2020-12-20","objectID":"/06-docker-all/:14:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"修改docker默认配置文件 # 添加上下面这行 \"live-restore\": true docker server配置文件 /etc/docker/daemon.json 参考 [root@docker02 ~]# cat /etc/docker/daemon.json { \"registry-mirrors\": [\"https://registry.docker-cn.com\"], \"graph\": \"/opt/mydocker\", # 修改数据的存放目录到/opt/mydocker/，原/var/lib/docker/ \"insecure-registries\": [\"10.0.0.100:5000\"], \"live-restore\": true } 重启生效，只对在此之后启动的容器生效 [root@docker01 ~]# systemctl restart docker.service ","date":"2020-12-20","objectID":"/06-docker-all/:14:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker网络类型 ","date":"2020-12-20","objectID":"/06-docker-all/:15:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"docker的网络类型 Bridge默认docker网络隔离基于网络命名空间，在物理机上创建docker容器时会为每一个docker容器分配网络命名空间，并且把容器IP桥接到物理机的虚拟网桥上。 ","date":"2020-12-20","objectID":"/06-docker-all/:15:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"不为容器配置网络功能 此模式下创建容器是不会为容器配置任何网络参数的，如：容器网卡、IP、通信路由等，全部需要自己去配置。 [root@docker01 ~]# docker run -it --network none busybox:latest /bin/sh / # ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever ","date":"2020-12-20","objectID":"/06-docker-all/:15:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"与其他容器共享网络配置(Container） 此模式和host模式很类似，只是此模式创建容器共享的是其他容器的IP和端口而不是物理机，此模式容器自身是不会配置网络和端口，创建此模式容器进去后，你会发现里边的IP是你所指定的那个容器IP并且端口也是共享的，而且其它还是互相隔离的，如进程等。 [root@docker01 ~]# docker run -it --network container:mywordpress_db_1 busybox:latest /bin/sh / # ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 105: eth0@if106: \u003cBROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN\u003e mtu 1500 qdisc noqueue link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff inet 172.18.0.3/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever ","date":"2020-12-20","objectID":"/06-docker-all/:15:3","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"使用宿主机网络 此模式创建的容器没有自己独立的网络命名空间，是和物理机共享一个Network Namespace，并且共享物理机的所有端口与IP，并且这个模式认为是不安全的。 [root@docker01 ~]# docker run -it --network host busybox:latest /bin/sh ","date":"2020-12-20","objectID":"/06-docker-all/:15:4","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"查看网络列表 [root@docker01 ~]# docker network list NETWORK ID NAME DRIVER SCOPE b15e8a720d3b bridge bridge local 345d65b4c2a0 host host local bc5e2a32bb55 mywordpress_default bridge local ebf76eea91bb none null local ","date":"2020-12-20","objectID":"/06-docker-all/:15:5","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"用PIPEWORK为docker容器配置独立IP 参考文档： blog.csdn.net/design321/article/details/48264825 官方网站： github.com/jpetazzo/pipework 宿主环境：centos7.2 1、安装pipework wget https://github.com/jpetazzo/pipework/archive/master.zip unzip master.zip cp pipework-master/pipework /usr/local/bin/ chmod +x /usr/local/bin/pipework 2、配置桥接网卡 安装桥接工具 yum install bridge-utils.x86_64 -y 修改网卡配置，实现桥接 # 修改eth0配置，让br0实现桥接 [root@docker01 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 TYPE=Ethernet BOOTPROTO=static NAME=eth0 DEVICE=eth0 ONBOOT=yes BRIDGE=br0 [root@docker01 ~]# cat /etc/sysconfig/network-scripts/ifcfg-br0 TYPE=Bridge BOOTPROTO=static NAME=br0 DEVICE=br0 ONBOOT=yes IPADDR=10.0.0.100 NETMASK=255.255.255.0 GATEWAY=10.0.0.254 DNS1=223.5.5.5 # 重启网络 [root@docker01 ~]# /etc/init.d/network restart 3、运行一个容器镜像测试： pipework br0 $(docker run -d -it -p 6880:80 --name httpd_pw httpd) 10.0.0.220/24@10.0.0.254 在其他主机上测试端口及连通性 [root@docker01 ~]# curl 10.0.0.220 \u003chtml\u003e\u003cbody\u003e\u003ch1\u003eIt works!\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e [root@docker01 ~]# ping 10.0.0.220 -c 1 PING 10.0.0.220 (10.0.0.220) 56(84) bytes of data. 64 bytes from 10.0.0.220: icmp_seq=1 ttl=64 time=0.043 ms 4、再运行一个容器，设置网路类型为none： pipework br0 $(docker run -d -it --net=none --name test httpd:2.4) 10.0.0.221/24@10.0.0.254 进行访问测试 [root@docker01 ~]# curl 10.0.0.221 \u003chtml\u003e\u003cbody\u003e\u003ch1\u003eIt works!\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e 5、重启容器后需要再次指定： pipework br0 testduliip 172.16.146.113/24@172.16.146.1 pipework br0 testduliip01 172.16.146.112/24@172.16.146.1 Dcoker跨主机通信之overlay可以参考： cnblogs.com/CloudMan6/p/7270551.html ","date":"2020-12-20","objectID":"/06-docker-all/:15:6","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"Docker跨主机通信之macvlan 创建网络 [root@docker01 ~]# docker network create --driver macvlan --subnet 10.1.0.0/24 --gateway 10.1.0.254 -o parent=eth0 macvlan_1 33a1f41dcc074f91b5bd45e7dfedabfb2b8ec82db16542f05213839a119b62ca 设置网卡为混杂模式 ip link set eth0 promisc on 创建使用macvlan网络容器 [root@docker02 ~]# docker run -it --network macvlan_1 --ip=10.1.0.222 busybox /b ","date":"2020-12-20","objectID":"/06-docker-all/:15:7","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"docker企业级镜像仓库harbor 容器管理 [root@docker01 harbor]# pwd /opt/harbor [root@docker01 harbor]# docker-compose stop 1、安装docker、docker-compose 下载 harbor cd /opt \u0026\u0026 https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.3.0.tgz tar xf harbor-offline-installer-v1.3.0.tgz 2、修改主机及web界面密码 [root@docker01 harbor]# vim harbor.cfg ··· hostname = 10.0.0.100 harbor_admin_password = Harbor12345 ··· 3、执行安装脚本 [root@docker01 harbor]# ./install.sh 浏览器访问 http://10.0.0.11 添加一个项目 4、镜像推送到仓库的指定项目 [root@docker02 ~]# docker tag centos:6.8 10.0.0.100/clsn/centos6.8:1.0 [root@docker02 ~]# [root@docker02 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 5b0d59026729 8 days ago 1.15MB 10.0.0.100/clsn/centos6.8 1.0 6704d778b3ba 2 months ago 195MB centos 6.8 6704d778b3ba 2 months ago 195MB [root@docker02 ~]# docker login 10.0.0.100 Username: admin Password: Login Succeeded 5、推送镜像 [root@docker02 ~]# docker push 10.0.0.100/clsn/centos6.8 The push refers to repository [10.0.0.100/clsn/centos6.8] e00c9229b481: Pushing 13.53MB/194.5MB 6、在web界面里查看 ","date":"2020-12-20","objectID":"/06-docker-all/:16:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"使用容器的建议 \\1. 不要以拆分方式进行应用程序发布 \\2. 不要创建大型镜像 \\3. 不要在单个容器中运行多个进程 \\4. 不要再镜像内保存凭证，不要依赖IP地址 \\5. 以非root用户运行进程 \\6. 不要使用“最新”标签 \\7. 不要利用运行中的容器创建镜像 \\8. 不要使用单层镜像 \\9. 不要将数据存放在容器内 ","date":"2020-12-20","objectID":"/06-docker-all/:16:1","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"关于Docker容器的监控 容器的基本信息 包括容器的数量、ID、名称、镜像、启动命令、端口等信息 容器的运行状态 统计各状态的容器的数量，包括运行中、暂停、停止及异常退出 容器的用量信息 统计容器的CPU使用率、内存使用量、块设备I/O使用量、网络使用情况等资源的使用情况 ","date":"2020-12-20","objectID":"/06-docker-all/:16:2","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["编程"],"content":"参考文献 redhat.com/zh/topics/containers/whats-a-linux-container redhat.com/zh/topics/containers/what-is-docker blog.51cto.com/dihaifeng/1713512 cnblogs.com/Bourbon-tian/p/6867796.html cnblogs.com/CloudMan6/p/6806193.html ","date":"2020-12-20","objectID":"/06-docker-all/:17:0","tags":["编程"],"title":"【Docker】Docker从入门到干活，看这一篇足矣","uri":"/06-docker-all/"},{"categories":["go"],"content":"简单的介绍一下go mod的基础使用。","date":"2020-12-20","objectID":"/09-go-module/","tags":["go"],"title":"【Go】go mod 的基础使用","uri":"/09-go-module/"},{"categories":["go"],"content":"简述 简单的介绍一下go mod的基础使用，由于我开始学习Go的时间比较晚，已经大部分的项目都是从GoPath到Go mod的转换了，统一使用go.mod的方式管理，所以没有遇到什么难题，但是具体怎么使用也不太清楚，今天一起来学习一下go mod的使用方法。 ","date":"2020-12-20","objectID":"/09-go-module/:1:0","tags":["go"],"title":"【Go】go mod 的基础使用","uri":"/09-go-module/"},{"categories":["go"],"content":"什么是go module？ module是一个相关GO包的集合，它是源代码更替和版本控制的单元。 模块由源文件形成的go.mod文件的根目录定义，包含go.mod文件的目录也被称为模块根 ","date":"2020-12-20","objectID":"/09-go-module/:2:0","tags":["go"],"title":"【Go】go mod 的基础使用","uri":"/09-go-module/"},{"categories":["go"],"content":"go.mod文件 go.mod文件定义module路径以及列出其他需要在build时引入的模块的特定的版本。 go.mod文件用//注释，而不用/**/。文件的每行都有一条指令，由一个动作加上参数组成。 三个动词require、exclude、replace分别表示：项目需要的依赖包及版本、排除某些包的特别版本、取代当前项目中的某些依赖包 有一个专门的命令go mod tidy，用来查看和添加缺失的module需求声明以及移除不必要的 eg: module example.com/m require ( golang.org/x/text v0.3.0 gopkg.in/yaml.v2 v2.1.0 ) 具体使用步骤: 首先将你的版本更新到最新的Go版本(\u003e=1.11)，如何更新版本可以自行百度。 通过go命令行，进入到你当前的工程目录下，在命令行设置临时环境变量set GO111MODULE=on； 执行命令go mod init在当前目录下生成一个go.mod文件，执行这条命令时，当前目录不能存在go.mod文件。如果之前生成过，要先删除； 如果你工程中存在一些不能确定版本的包，那么生成的go.mod文件可能就不完整，因此继续执行下面的命令； 执行go mod tidy命令，它会添加缺失的模块以及移除不需要的模块。执行后会生成go.sum文件(模块下载条目)。添加参数-v，例如go mod tidy -v可以将执行的信息，即删除和添加的包打印到命令行； 执行命令go mod verify来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印all modules verified。 执行命令go mod vendor生成vendor文件夹，该文件夹下将会放置你go.mod文件描述的依赖包，文件夹下同时还有一个文件modules.txt，它是你整个工程的所有模块。在执行这条命令之前，如果你工程之前有vendor目录，应该先进行删除。同理go mod vendor -v会将添加到vendor中的模块打印出来； ","date":"2020-12-20","objectID":"/09-go-module/:3:0","tags":["go"],"title":"【Go】go mod 的基础使用","uri":"/09-go-module/"},{"categories":["go"],"content":"总结 go mod init和go mod tidy两个主要的命令记住就行。 go get (下载依赖的包)和go get -u（更新依赖的包到最新版本） ","date":"2020-12-20","objectID":"/09-go-module/:4:0","tags":["go"],"title":"【Go】go mod 的基础使用","uri":"/09-go-module/"},{"categories":["blog"],"content":"简单的介绍现代计算机之父.","date":"2020-12-20","objectID":"/03-john-von-neumann/","tags":["blog"],"title":"【人物】现代计算机之父 约翰·冯·诺依曼","uri":"/03-john-von-neumann/"},{"categories":["blog"],"content":"简述 简单的介绍现在计算机之父、约翰·冯·诺依曼 和 冯·诺依曼体系结构 ","date":"2020-12-20","objectID":"/03-john-von-neumann/:1:0","tags":["blog"],"title":"【人物】现代计算机之父 约翰·冯·诺依曼","uri":"/03-john-von-neumann/"},{"categories":["blog"],"content":"约翰·冯·诺依曼 冯·诺依曼（John von Neumann，1903年12月28日-1957年2月8日），美籍匈牙利数学家、计算机科学家、物理学家，是20世纪最重要的数学家之一。冯·诺依曼是布达佩斯大学数学博士，是现代计算机、博弈论、核武器和生化武器等领域内的科学全才之一，被后人称为“现代计算机之父”、“博弈论之父”。 ","date":"2020-12-20","objectID":"/03-john-von-neumann/:2:0","tags":["blog"],"title":"【人物】现代计算机之父 约翰·冯·诺依曼","uri":"/03-john-von-neumann/"},{"categories":["blog"],"content":"冯 · 若依曼体系结构 现代社会中所有电脑都是通过这个体系结构来建立的。所有电脑都是由输入设备（键盘、鼠标等），存储设备（内存条、硬盘等），运算设备（CPU、GPU），还有控制设备，去控制输出设备（显示器、摄像头等）这几种基本设备所构成。 计算机中的IO，指的是单词input输入和output输出，也就是计算机的输入输出。 体系结构体系结构 \" 体系结构 ","date":"2020-12-20","objectID":"/03-john-von-neumann/:3:0","tags":["blog"],"title":"【人物】现代计算机之父 约翰·冯·诺依曼","uri":"/03-john-von-neumann/"},{"categories":["tools"],"content":"Dos常用命令的简介.","date":"2020-12-20","objectID":"/03-dos-cmd/","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"简述 目前大部分的情况，公司开发还是使用window的系统，那么cmd和powershell相关常用的命令我们就必须掌握它，linux能做的相关简单的操作，windows也得学习学习。这篇就说说平常常用的window命令。 ","date":"2020-12-20","objectID":"/03-dos-cmd/:1:0","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"开始 说说我自己吧，可能是个人习惯的问题，能通过命令行操作的事情，就尽量不要使用到鼠标，习惯让自己的手尽量的不离开键盘。可能这样做的目的，对写代码的注意力集中也有一定的好处吧，让双手掌握代码。所以自己会记忆大量的工具的快捷键和命令，也不知道是不是一个好的习惯。不过长期以后就变的是肌肉记忆，可能划得来。 ","date":"2020-12-20","objectID":"/03-dos-cmd/:2:0","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"Dos 磁盘操作系统（Disk Operating System），简单的理解，可以认为是目前windows的 cmd 和 powershell，非程序开发可能已经基本上使用不到了，但是cmd应该还是windows打开系统相关软件最快捷的方式之一。 ","date":"2020-12-20","objectID":"/03-dos-cmd/:3:0","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"如何打开cmd 开始-\u003ewindows系统-\u003e命令提示符（win10系统） win键+R 输入cmd（推荐使用） 在任意的文件夹下面,按住shft建+鼠标右键，点击在此处打开命令行窗口（win10是powershell窗口） 资源管理的地址栏的路径前面加上cmd然后空格，回车即可 第二种应该是最常用的一种方法，但是最后一种的话，是推荐需要打开指定目录下执行cmd的最好方法。 ","date":"2020-12-20","objectID":"/03-dos-cmd/:4:0","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"常用的命令 ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:0","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"盘符切换 D: // 盘符名称+: ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:1","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"打开应用 calc mspaint notepad ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:2","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"dir 类似linux的ls ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:3","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"copy copy [要复制的文件名] [复制到的路径或文件夹] ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:4","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"move move [要移动的文件名] [文件移到的路径或文件夹] ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:5","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"md 该命令用于新建目录。语法是： md [path表示即将创建的目录的路径] [directoryname表示所有创建的目录名称，此参数必须要有] ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:6","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"cd 该命令用于改变当前目录 cd .. // 上一级目录，这个很重要，同linux ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:7","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"ren 该命令用于重命名文件或文件夹。语法是： ren [oldfilename旧名字] [newfilename新名字] ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:8","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"del 该命令用于删除目录中的文件。要删除其它驱动器或目录中的文件，则必须指定路径。语法是： del [filename表示要删除的文件名] ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:9","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"rd 该命令用于删除文件夹。语法是： rd [directoryname表示要删除的文件夹名称] ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:10","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"cls 该命令用于清除屏幕。 ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:11","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"exit 该命令用于退出CMD.EXE 程序。 ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:12","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"ipconfig 查看网络信息 ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:13","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"ping 查看IP对应的网络地址和域名 ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:14","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"netstat 本地地址监听信息查看 ","date":"2020-12-20","objectID":"/03-dos-cmd/:5:15","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["tools"],"content":"总结 ​ 整理一些平常常用的Dos命令，后续有忘记的情况，可以查看如何使用，目前使用vscode输入命令行的情况也是比较经常的情况。 ","date":"2020-12-20","objectID":"/03-dos-cmd/:6:0","tags":["tools"],"title":"【cmd】Dos常用命令，cmd你会用吗？","uri":"/03-dos-cmd/"},{"categories":["编程"],"content":"jaeger: open source, end-to-end distributed tracing Monitor and troubleshoot transactions in complex distributed systems.","date":"2020-12-20","objectID":"/05-jaeger-deploy/","tags":["编程"],"title":"【jaeger】最简单的jaeger测试环境部署教程","uri":"/05-jaeger-deploy/"},{"categories":["编程"],"content":"jaeger: open source, end-to-end distributed tracing Monitor and troubleshoot transactions in complex distributed systems.. ","date":"2020-12-20","objectID":"/05-jaeger-deploy/:0:0","tags":["编程"],"title":"【jaeger】最简单的jaeger测试环境部署教程","uri":"/05-jaeger-deploy/"},{"categories":["编程"],"content":"简述 ​ Jaeger: open source, end-to-end distributed tracing Monitor and troubleshoot transactions in complex distributed systems ","date":"2020-12-20","objectID":"/05-jaeger-deploy/:1:0","tags":["编程"],"title":"【jaeger】最简单的jaeger测试环境部署教程","uri":"/05-jaeger-deploy/"},{"categories":["编程"],"content":"Why Jaeger? ​ As on-the-ground microservice practitioners are quickly realizing, the majority of operational problems that arise when moving to a distributed architecture are ultimately grounded in two areas: networking and observability. It is simply an orders of magnitude larger problem to network and debug a set of intertwined distributed services versus a single monolithic application. ","date":"2020-12-20","objectID":"/05-jaeger-deploy/:1:1","tags":["编程"],"title":"【jaeger】最简单的jaeger测试环境部署教程","uri":"/05-jaeger-deploy/"},{"categories":["编程"],"content":"部署说明 Jaeger官网入门指南 ","date":"2020-12-20","objectID":"/05-jaeger-deploy/:2:0","tags":["编程"],"title":"【jaeger】最简单的jaeger测试环境部署教程","uri":"/05-jaeger-deploy/"},{"categories":["编程"],"content":"All in One All-in-one is an executable designed for quick local testing, launches the Jaeger UI, collector, query, and agent, with an in memory storage component. The simplest way to start the all-in-one is to use the pre-built image published to DockerHub (a single command line). $ docker run -d --name jaeger \\ -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 14250:14250 \\ -p 9411:9411 \\ jaegertracing/all-in-one:1.21 使用docker部署，jaeger测试的所有服务. Port Protocol Component Function 5775 UDP agent accept zipkin.thrift over compact thrift protocol (deprecated, used by legacy clients only) 6831 UDP agent accept jaeger.thrift over compact thrift protocol 6832 UDP agent accept jaeger.thrift over binary thrift protocol 5778 HTTP agent serve configs 16686 HTTP query serve frontend 14268 HTTP collector accept jaeger.thrift directly from clients 14250 HTTP collector accept model.proto 9411 HTTP collector Zipkin compatible endpoint (optional) ","date":"2020-12-20","objectID":"/05-jaeger-deploy/:2:1","tags":["编程"],"title":"【jaeger】最简单的jaeger测试环境部署教程","uri":"/05-jaeger-deploy/"},{"categories":["编程"],"content":"总结 ​ docker方式部署开源服务，使得部署变得尤为的简单，这边也是简单的说明一个docker部署的例子，为之前学习的Docker知识做一个实践. ","date":"2020-12-20","objectID":"/05-jaeger-deploy/:3:0","tags":["编程"],"title":"【jaeger】最简单的jaeger测试环境部署教程","uri":"/05-jaeger-deploy/"},{"categories":["编程"],"content":"介绍docker运行的方式，相关参数的说明，以及具体的实战和常用的参数信息.","date":"2020-12-19","objectID":"/04-docker-run/","tags":["编程"],"title":"【docker】Docker Run 的使用介绍和实战","uri":"/04-docker-run/"},{"categories":["编程"],"content":"介绍docker运行的方式，相关参数的说明，以及具体的实战和常用的参数信息. ","date":"2020-12-19","objectID":"/04-docker-run/:0:0","tags":["编程"],"title":"【docker】Docker Run 的使用介绍和实战","uri":"/04-docker-run/"},{"categories":["编程"],"content":"简述 简要的说明 docker run 的使用，说明如何运行一个容器。 ","date":"2020-12-19","objectID":"/04-docker-run/:1:0","tags":["编程"],"title":"【docker】Docker Run 的使用介绍和实战","uri":"/04-docker-run/"},{"categories":["编程"],"content":"参数说明 $ docker run --help Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Run a command in a new container Options: --add-host list Add a custom host-to-IP mapping (host:ip) -a, --attach list Attach to STDIN, STDOUT or STDERR --blkio-weight uint16 Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0) --blkio-weight-device list Block IO weight (relative device weight) (default []) --cap-add list Add Linux capabilities --cap-drop list Drop Linux capabilities --cgroup-parent string Optional parent cgroup for the container --cgroupns string Cgroup namespace to use (host|private) 'host': Run the container in the Docker host's cgroup namespace 'private': Run the container in its own private cgroup namespace '': Use the cgroup namespace as configured by the default-cgroupns-mode option on the daemon (default) --cidfile string Write the container ID to the file --cpu-period int Limit CPU CFS (Completely Fair Scheduler) period --cpu-quota int Limit CPU CFS (Completely Fair Scheduler) quota --cpu-rt-period int Limit CPU real-time period in microseconds --cpu-rt-runtime int Limit CPU real-time runtime in microseconds -c, --cpu-shares int CPU shares (relative weight) --cpus decimal Number of CPUs --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) -d, --detach Run container in background and print container ID --detach-keys string Override the key sequence for detaching a container --device list Add a host device to the container --device-cgroup-rule list Add a rule to the cgroup allowed devices list --device-read-bps list Limit read rate (bytes per second) from a device (default []) --device-read-iops list Limit read rate (IO per second) from a device (default []) --device-write-bps list Limit write rate (bytes per second) to a device (default []) --device-write-iops list Limit write rate (IO per second) to a device (default []) --disable-content-trust Skip image verification (default true) --dns list Set custom DNS servers --dns-option list Set DNS options --dns-search list Set custom DNS search domains --domainname string Container NIS domain name --entrypoint string Overwrite the default ENTRYPOINT of the image -e, --env list Set environment variables --env-file list Read in a file of environment variables --expose list Expose a port or a range of ports --gpus gpu-request GPU devices to add to the container ('all' to pass all GPUs) --group-add list Add additional groups to join --health-cmd string Command to run to check health --health-interval duration Time between running the check (ms|s|m|h) (default 0s) --health-retries int Consecutive failures needed to report unhealthy --health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) --health-timeout duration Maximum time to allow one check to run (ms|s|m|h) (default 0s) --help Print usage -h, --hostname string Container host name --init Run an init inside the container that forwards signals and reaps processes -i, --interactive Keep STDIN open even if not attached --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --ipc string IPC mode to use --isolation string Container isolation technology --kernel-memory bytes Kernel memory limit -l, --label list Set meta data on a container --label-file list Read in a line delimited file of labels --link list Add link to another container --link-local-ip list Container IPv4/IPv6 link-local addresses --log-driver string Logging driver for the container --log-opt list Log driver options --mac-address string Container MAC address (e.g., 92:d0:c6:0a:29:33) -m, --memory bytes Memory limit --memory-reservation bytes Memory soft limit --memory-swap bytes Swap limit equal to memory plus swap: '-1' to enable unlimited swap --memory-swappiness int Tune container memory swappiness (0 to 100) (default -1) --mount mount Attach a fil","date":"2020-12-19","objectID":"/04-docker-run/:2:0","tags":["编程"],"title":"【docker】Docker Run 的使用介绍和实战","uri":"/04-docker-run/"},{"categories":["编程"],"content":"参数解析 OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=“nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=“ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=“0-2” or –cpuset=“0,1,2”: 绑定容器到指定CPU运行； **-m :**设置容器使用内存最大值； –net=“bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 ","date":"2020-12-19","objectID":"/04-docker-run/:3:0","tags":["编程"],"title":"【docker】Docker Run 的使用介绍和实战","uri":"/04-docker-run/"},{"categories":["编程"],"content":"实例 –restart=always 开机自启程序 -d 后台运行 使用 /usr/sbin/init 可以支持 systemctl 实战: ​ docker run -d --rm -it --network=host --name=HTTPServer --privileged coolliuzw:go bash ","date":"2020-12-19","objectID":"/04-docker-run/:4:0","tags":["编程"],"title":"【docker】Docker Run 的使用介绍和实战","uri":"/04-docker-run/"},{"categories":["编程"],"content":"总结 实践运行docker image ","date":"2020-12-19","objectID":"/04-docker-run/:5:0","tags":["编程"],"title":"【docker】Docker Run 的使用介绍和实战","uri":"/04-docker-run/"},{"categories":["编程"],"content":"编写Dockerfile，实现go程序的编译和运行.","date":"2020-12-19","objectID":"/03-dockerfile/","tags":["编程"],"title":"【docker】最简单的Go Dockerfile编写姿势实战","uri":"/03-dockerfile/"},{"categories":["编程"],"content":"编写Dockerfile，实现go程序的编译和运行. ","date":"2020-12-19","objectID":"/03-dockerfile/:0:0","tags":["编程"],"title":"【docker】最简单的Go Dockerfile编写姿势实战","uri":"/03-dockerfile/"},{"categories":["编程"],"content":"简述 docker是目前微服务部署场景中，非常重要的工具，目前大部分的公司都是使用docker+k8s实现集群化的部署。docker是Go语言编写的，那么今天简单的说明一下Go语言编译与运行的实战，使用多阶段 ","date":"2020-12-19","objectID":"/03-dockerfile/:1:0","tags":["编程"],"title":"【docker】最简单的Go Dockerfile编写姿势实战","uri":"/03-dockerfile/"},{"categories":["编程"],"content":"实例 使用多阶段构建的docker镜像的实例，实践，测试可用，应该可以直接用。 # 使用golang:1.15.6-alpine3.12作为编译的基础镜像 FROM golang:1.15.6-alpine3.12 AS builder # 相关的标签 LABEL version=\"golang:1.15.6-alpine3.12\" \\ description=\"make go meeting ctrl\" \\ author=\"Coolliuzw\" \\ stage=builder # go环境变量配置 ENV CGO_ENABLED=0 \\ GOOS=linux \\ GOPROXY=https://goproxy.cn,direct \\ GOARCH=amd64 ENV APP_NAME=\"main\" # 编译的工作目录 WORKDIR /build/go ## 使用aliyun的镜像加速服务. RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories # go mod 的镜像下载，可以缓存 ADD go.mod . ADD go.sum . RUN go mod download # 编译go程序 COPY . . RUN go build -ldflags=\"-s -w\" -o ${APP_NAME} # 使用最小镜像运行 FROM alpine:3.12 ## 使用aliyun的镜像加速服务. RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories # 安装相关需要的工具包 RUN apk update \\ \u0026\u0026 apk add ca-certificates \\ -U tzdata \\ bash \\ bash-doc \\ bash-completion \\ ca-certificates \\ \u0026\u0026 rm -rf /var/cache/apk/* ## 设置时区信息 RUN rm -rf /etc/localtime \u0026\u0026 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 运行目录的构建 ENV APP_BUILD /build/go ENV APP_NAME main ENV APP_ROOT root/opt/${APP_NAME} # RUN mkdir -p ${APP_ROOT} #暴露端口 EXPOSE 8080 # 工作目录 WORKDIR ${APP_ROOT} COPY --from=builder ${APP_BUILD}/${APP_NAME} ./bin/${APP_NAME} CMD ./bin/${APP_NAME} docker build -t coolliuzw:go . ","date":"2020-12-19","objectID":"/03-dockerfile/:2:0","tags":["编程"],"title":"【docker】最简单的Go Dockerfile编写姿势实战","uri":"/03-dockerfile/"},{"categories":["编程"],"content":"清除未使用镜像 方法一 docker rmi $(sudo docker images --filter dangling=true -q) 方法二 // 清除构建的中间镜像 FROM node as builder LABEL stage=builder ... FROM node:dubnium-alpine docker image prune --filter label=stage=builder 方法三 docker system prune ","date":"2020-12-19","objectID":"/03-dockerfile/:2:1","tags":["编程"],"title":"【docker】最简单的Go Dockerfile编写姿势实战","uri":"/03-dockerfile/"},{"categories":["编程"],"content":"总结 实践测试，构建简单的http服务程序 coolliuzw go 7f9b79a9e681 7 minutes ago 19.7MB 测试成功 ","date":"2020-12-19","objectID":"/03-dockerfile/:3:0","tags":["编程"],"title":"【docker】最简单的Go Dockerfile编写姿势实战","uri":"/03-dockerfile/"},{"categories":["编程"],"content":"简单的学习一下dockerFile的编写.","date":"2020-12-18","objectID":"/02-dockerfile/","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"Dockerfile编写的基础教程，目的是基本能实现Dockerfile的编写和构建属于自己的Docker Images. ","date":"2020-12-18","objectID":"/02-dockerfile/:0:0","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"简述 什么是 Dockerfile？ Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 ","date":"2020-12-18","objectID":"/02-dockerfile/:1:0","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"指令说明 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:0","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"FROM 定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像 // 三种写法，其中\u003ctag\u003e和\u003cdigest\u003e 是可选项，如果没有选择，那么默认值为latest FROM \u003cimage\u003e FROM \u003cimage\u003e:\u003ctag\u003e FROM \u003cimage\u003e:\u003cdigest\u003e  ","date":"2020-12-18","objectID":"/02-dockerfile/:2:1","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"RUN 用于执行后面跟着的命令行命令 RUN的两种格式: shell 格式： RUN \u003c命令行命令\u003e # \u003c命令行命令\u003e 等同于，在终端操作的 shell 命令。 exec 格式： RUN [\"可执行文件\", \"参数1\", \"参数2\"] # 例如： # RUN [\"./test.php\", \"dev\", \"offline\"] 等价于 RUN ./test.php dev offline 注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如： FROM centos RUN yum install wget RUN wget -O redis.tar.gz “http://download.redis.io/releases/redis-5.0.3.tar.gz\" RUN tar -xvf redis.tar.gz 以上执行会创建 3 层镜像。可简化为以下格式： FROM centos RUN yum install wget \u0026\u0026 wget -O redis.tar.gz “http://download.redis.io/releases/redis-5.0.3.tar.gz\" \u0026\u0026 tar -xvf redis.tar.gz ``` 如上，以 **\u0026\u0026** 符号连接命令，这样执行后，只会创建 1 层镜像。 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:2","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"COPY 复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 格式： COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] \u003c源路径1\u003e... \u003c目标路径\u003e COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [\"\u003c源路径1\u003e\",... \"\u003c目标路径\u003e\"] [–chown=:]：可选参数，用户改变复制到容器内文件的拥有者和属组。 \u003c源路径\u003e：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如： COPY hom* /mydir/ COPY hom?.txt /mydir/ \u003c目标路径\u003e：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:3","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"ADD ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下： ADD 的优点：在执行 \u003c源文件\u003e 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 \u003c目标路径\u003e。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:4","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"CMD 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: CMD 在docker run 时运行。 RUN 是在 docker build。 作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 格式： CMD \u003cshell 命令\u003e CMD [\"\u003c可执行文件或命令\u003e\",\"\u003cparam1\u003e\",\"\u003cparam2\u003e\",...] CMD [\"\u003cparam1\u003e\",\"\u003cparam2\u003e\",...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:5","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"ENTRYPOINT 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。 但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。 优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。 注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 格式： ENTRYPOINT [\"\u003cexecuteable\u003e\",\"\u003cparam1\u003e\",\"\u003cparam2\u003e\",...] 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。 示例： 假设已通过 Dockerfile 构建了 nginx:test 镜像： FROM nginx ENTRYPOINT [\"nginx\", \"-c\"] # 定参 CMD [\"/etc/nginx/nginx.conf\"] # 变参 1、不传参运行 $ docker run nginx:test 容器内会默认运行以下命令，启动主进程。 nginx -c /etc/nginx/nginx.conf 2、传参运行 $ docker run nginx:test -c /etc/nginx/new.conf 容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件) nginx -c /etc/nginx/new.conf ","date":"2020-12-18","objectID":"/02-dockerfile/:2:6","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"ENV 设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 格式： ENV \u003ckey\u003e \u003cvalue\u003e ENV \u003ckey1\u003e=\u003cvalue1\u003e \u003ckey2\u003e=\u003cvalue2\u003e... 以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用： ENV NODE_VERSION 7.2.0 RUN curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\" \\ \u0026\u0026 curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\" ","date":"2020-12-18","objectID":"/02-dockerfile/:2:7","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"ARG 构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。 构建命令 docker build 中可以用 –build-arg \u003c参数名\u003e=\u003c值\u003e 来覆盖。 格式： ARG \u003c参数名\u003e[=\u003c默认值\u003e] ","date":"2020-12-18","objectID":"/02-dockerfile/:2:8","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"VOLUME 定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。 作用： 避免重要的数据，因容器重启而丢失，这是非常致命的。 避免容器不断变大。 格式： VOLUME [\"\u003c路径1\u003e\", \"\u003c路径2\u003e\"...] VOLUME \u003c路径\u003e 在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:9","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"EXPOSE 仅仅只是声明端口。 作用： 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 格式： EXPOSE \u003c端口1\u003e [\u003c端口2\u003e...] ","date":"2020-12-18","objectID":"/02-dockerfile/:2:10","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"WORKDIR 指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。 docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。 格式： WORKDIR \u003c工作目录路径\u003e ","date":"2020-12-18","objectID":"/02-dockerfile/:2:11","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"USER 用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。 格式： USER \u003c用户名\u003e[:\u003c用户组\u003e] ","date":"2020-12-18","objectID":"/02-dockerfile/:2:12","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"HEALTHCHECK 用于指定某个程序或者指令来监控 docker 容器服务的运行状态。 格式： HEALTHCHECK [选项] CMD \u003c命令\u003e：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 HEALTHCHECK [选项] CMD \u003c命令\u003e : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:13","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"ONBUILD 用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。 格式： ONBUILD \u003c其它指令\u003e ","date":"2020-12-18","objectID":"/02-dockerfile/:2:14","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"LABEL 功能是为镜像指定标签 语法： LABEL \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e ... 一个Dockerfile种可以有多个LABEL，如下： LABEL \"com.example.vendor\"=\"ACME Incorporated\" LABEL com.example.label-with-value=\"foo\" LABEL version=\"1.0\" LABEL description=\"This text illustrates \\ that label-values can span multiple lines.\" 但是并不建议这样写，最好就写成一行，如太长需要换行的话则使用\\符号 如下： LABEL multi.label1=\"value1\" \\ multi.label2=\"value2\" \\ other=\"value3\" 说明：LABEL会继承基础镜像中的LABEL，如遇到key相同，则值覆盖 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:15","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"MAINTAINER 指定作者 语法： MAINTAINER \u003cname\u003e ","date":"2020-12-18","objectID":"/02-dockerfile/:2:16","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"STOPSIGNAL 语法： STOPSIGNAL signal STOPSIGNAL命令是的作用是当容器推出时给系统发送什么样的指令 ","date":"2020-12-18","objectID":"/02-dockerfile/:2:17","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"构建镜像 docker build -t coolliuzw:go . 注意：上下文路径(这边的 点，也就是构建的路径)下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。 ","date":"2020-12-18","objectID":"/02-dockerfile/:3:0","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"构建参数说明 docker build 命令用于使用 Dockerfile 创建镜像，语法 docker build [OPTIONS] PATH | URL |- 参数说明： –build-arg=[] : 设置镜像创建时的变量； –cpu-shares : 设置 cpu 使用权重； –cpu-period : 限制 CPU CFS周期； –cpu-quota : 限制 CPU CFS配额； –cpuset-cpus : 指定使用的CPU id； –cpuset-mems : 指定使用的内存 id； –disable-content-trust : 忽略校验，默认开启； -f : 指定要使用的Dockerfile路径； –force-rm : 设置镜像过程中删除中间容器； –isolation : 使用容器隔离技术； –label=[] : 设置镜像使用的元数据； -m : 设置内存最大值； –memory-swap : 设置Swap的最大值为内存+swap，\"-1\"表示不限swap； –no-cache : 创建镜像的过程不使用缓存； –pull : 尝试去更新镜像的新版本； –quiet, -q : 安静模式，成功后只输出镜像 ID； –rm : 设置镜像成功后删除中间容器； –shm-size : 设置/dev/shm的大小，默认值是64M； –ulimit : Ulimit配置。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 –network: 默认 default。在构建期间设置RUN指令的网络模式 ","date":"2020-12-18","objectID":"/02-dockerfile/:3:1","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["编程"],"content":"总结 详细的说明了一些Dockerfile的指令，以及docker build的相关参数信息. ","date":"2020-12-18","objectID":"/02-dockerfile/:4:0","tags":["编程"],"title":"【docker】DockerFile的编写基础文档","uri":"/02-dockerfile/"},{"categories":["go"],"content":"简单的通过测试的代码对HTTP1.0和HTTP2.0做对比，基本分析一下HTTP2.0的性能有多强。","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"简单的通过测试的代码对HTTP1.0和HTTP2.0做对比，基本分析一下HTTP2.0的性能有多强。 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:0:0","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"简述 简单的通过测试的代码对HTTP1.0和HTTP2.0做对比，基本分析一下HTTP2.0的性能有多强。 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:1:0","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"准备工作 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:2:0","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"制作证书 方法一 1生成服务端私钥 openssl genrsa -out default.key 2048 2生成服务端证书 openssl req -new -x509 -key default.key -out default.pem -days 3650 方法二 generate-tls-cert --host=localhost,127.0.0.1 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:2:1","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"校验证书 因为我们是X509格式签名的证书所以程序做好先做一下有效性校验 if _, err = tls.LoadX509KeyPair(\"default.pem\", \"default.key\"); err != nil { panic(err) } ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:2:2","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"HTTPServer HTTP的服务使用的gin框架。 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:2:3","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"测试环境 - 查询配置的方法 echo -n \"CPU型号: \" sysctl -n machdep.cpu.brand_string echo -n \"CPU核心数: \" sysctl -n machdep.cpu.core_count echo -n \"CPU线程数: \" sysctl -n machdep.cpu.thread_count echo \"其它信息：\" system_profiler SPDisplaysDataType SPMemoryDataType SPStorageDataType | grep 'Graphics/Displays:\\|Chipset Model:\\|VRAM (Total):\\|Resolution:\\|Memory Slots:\\|Size:\\|Speed:\\|Storage:\\|Media Name:\\|Medium Type:' 本篇的测试使用Mac系统测试，配置如下: -n CPU型号:Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz -n CPU核心数:4 -n CPU线程数:8 其它信息： Graphics/Displays: Chipset Model: Intel Iris Pro Resolution: 2880 x 1800 Retina Memory Slots: Size: 8 GB Speed: 1600 MHz Size: 8 GB Speed: 1600 MHz Storage: Media Name: AppleAPFSMedia Medium Type: SSD Media Name: AppleAPFSMedia Medium Type: SSD 建议使用Linux系统测试，最好的方式应该是和项目的生产环境相同配置测试 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:2:4","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"编码测试 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:3:0","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"HTTP1.1 package _1_http import ( \"log\" \"net/http\" \"testing\" \"time\" \"github.com/gin-gonic/gin\" ) const HTTPListenAddr = \":6666\" func testRunHTTPSServer() { router := gin.New() go func() { if err := router.Run(HTTPListenAddr); err != nil { log.Fatalf(\"HTTP server: run failed. error: %v\", err) } }() } var client http.Client func init() { testRunHTTPSServer() client.Timeout = 10 * time.Second } func BenchmarkHTTP(b *testing.B) { for i := 0; i \u003c b.N; i++ { req, err := http.NewRequest(http.MethodGet, \"http://127.0.0.1\"+HTTPListenAddr, nil) if err != nil { panic(err) } _, _ = client.Do(req) } } ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:3:1","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"HTTP2.0 package _2_http2 import ( \"crypto/tls\" \"log\" \"net/http\" \"testing\" \"time\" \"github.com/gin-gonic/gin\" \"golang.org/x/net/http2\" ) const HTTPSListenAddr = \":6666\" func testRunHTTPSServer() { router := gin.New() if _, err := tls.LoadX509KeyPair(\"test.pem\", \"test.key\"); err != nil { log.Fatalf(\"HTTPS server: invalid cert\") } go func() { if err := router.RunTLS(HTTPSListenAddr, \"test.pem\", \"test.key\"); err != nil { log.Fatalf(\"HTTPS server: run failed. error: %v\", err) } }() } var client http.Client func init() { testRunHTTPSServer() client.Timeout = 10 * time.Second client.Transport = \u0026http2.Transport{TLSClientConfig: \u0026tls.Config{InsecureSkipVerify: true}} } func BenchmarkHTTP2(b *testing.B) { for i := 0; i \u003c b.N; i++ { req, err := http.NewRequest(http.MethodGet, \"https://127.0.0.1\"+HTTPSListenAddr, nil) if err != nil { panic(err) } _, _ = client.Do(req) } } ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:3:2","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"测试结果 在mac环境下，只做了简单的基础测试对比，使用Go的Benchmark测试的方法测试. ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:4:0","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"性能对比 GOMAXPROCS=1 HTTP1.1 $ GOMAXPROCS=1 go test -bench=. -benchmem -benchtime=10s [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] Listening and serving HTTP on :6666 goos: darwin goarch: amd64 pkg: gotest/01-http BenchmarkHTTP 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 5ms 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 10ms 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 20ms 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 40ms 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 80ms 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 160ms 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 320ms 2020/12/13 06:46:57 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 640ms 2020/12/13 06:46:58 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:46:59 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:47:00 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:47:01 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:47:02 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:47:03 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:47:04 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:47:05 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 10000 1249917 ns/op 22633 B/op 125 allocs/op PASS ok gotest/01-http 12.753s HTTP2.0 $ GOMAXPROCS=1 go test -bench=. -benchmem -benchtime=10s [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] Listening and serving HTTPS on :6666 goos: darwin goarch: amd64 pkg: gotest/02-http2 BenchmarkHTTP2 111625 105795 ns/op 7988 B/op 84 allocs/op PASS ok gotest/02-http2 13.421s GOMAXPROCS=4 HTTP1.1 $ GOMAXPROCS=4 go test -bench=. -benchmem -benchtime=10s [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] Listening and serving HTTP on :6666 goos: darwin goarch: amd64 pkg: gotest/01-http BenchmarkHTTP-4 2020/12/13 06:54:20 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 5ms 2020/12/13 06:54:20 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 10ms 2020/12/13 06:54:20 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 20ms 2020/12/13 06:54:20 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 40ms 2020/12/13 06:54:20 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 80ms 2020/12/13 06:54:20 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 160ms 2020/12/13 06:54:20 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 320ms 2020/12/13 06:54:21 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 640ms 2020/12/13 06:54:21 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s 2020/12/13 06:54:22 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:4:1","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"连接数对比 很明显的测试http的方式的情况，已经有打印错误的报错日志2020/12/13 06:47:05 http: Accept error: accept tcp [::]:6666: accept: too many open files; retrying in 1s，错误日志，简单的意思就是高并发的情况下打开句柄或者socket太多了，无法建立新的连接了，这里的问题来了，为什么报的是 too many open files? 那就是你知道的，linux一切皆是文件，写过c socket网络编程的应该知道，操作socket的方式，是不是和操作file很像。以下更新一下测试的具体参数信息? 简单的查看方法 $ netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n\u003c=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}' | grep 6666 $ netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n\u003c=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}' | TIME_WAIT // 查看各个TCP状态的数量信息 $ netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' HTTP1.1 $ netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n\u003c=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}' | grep 6666 127.0.0.1.6666 5119 $ netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n\u003c=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}' | grep TIME_WAIT TIME_WAIT 5130 需要使用大量的连接进行消息的传输，会队头堵塞原因吧。 这么看来，在持续并发的情况下，会建立非常多的连接资源的使用，如果有空闲的连接关闭的情况，会导致大量的TIME_WAIT消息，后导致后续连接的异常。 HTTP2.0 $ netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n\u003c=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}' | grep 6666 127.0.0.1.6666 1 目前显示HTTP2测试的情况，只有一个连接，具体也不清楚为什么？只知道HTTP2可以不用多连接，使用流ID的方式传输的，但是就一个连接，有点强。有没有发现一个问题，这边测试都是串行测试的，没有使用到并发测试的，会上会这个原因导致只有一个连接？ ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:4:2","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["go"],"content":"总结 这边只在本地的Mac上做了基础的测试，数据基本能体现出使用HTTPS的HTTP2.0可以有比较大的优势，但是测试的方式方法不全，之前也没有写过相关测试的文章，有什么建议的测试方便，建议指导 后续补充测试部分： 并行测试HTTP请求 Body对HTTP1.1和HTTP2.0性能的影响 Header对HTTP1.1和HTTP2.0性能的影响 应该还会有下一篇分析的。待补充。。。 ","date":"2020-12-13","objectID":"/07-http1.1-vs-http2.0/:5:0","tags":["go"],"title":"【Go】HTTP1.1和HTTP2.0 性能对比简单测试","uri":"/07-http1.1-vs-http2.0/"},{"categories":["tools"],"content":"如何玩转GitHub的扩展篇，实战实战演练.","date":"2020-12-12","objectID":"/02-github-search/","tags":["tools"],"title":"【tools】如何在Github找到你想要的项目？","uri":"/02-github-search/"},{"categories":["tools"],"content":"如何玩转GitHub的扩展篇，实战实战演练. ","date":"2020-12-12","objectID":"/02-github-search/:0:0","tags":["tools"],"title":"【tools】如何在Github找到你想要的项目？","uri":"/02-github-search/"},{"categories":["tools"],"content":"简述 全球最大的同性交友平台，程序员必备知识。那么如果在Githu取到自己想要的项目呢？ ","date":"2020-12-12","objectID":"/02-github-search/:1:0","tags":["tools"],"title":"【tools】如何在Github找到你想要的项目？","uri":"/02-github-search/"},{"categories":["tools"],"content":"开始 以获取一个 Go 语言的配置文件的库为例 需求: 支持加载local的config文件。 支持YAML, JSON, TOML多种格式。 最好支持同时获取环境变量的参数。 ","date":"2020-12-12","objectID":"/02-github-search/:2:0","tags":["tools"],"title":"【tools】如何在Github找到你想要的项目？","uri":"/02-github-search/"},{"categories":["tools"],"content":"一步一步来时间 初级程序员: config 查找config查找 \" config 查找 直接使用查到config的方式，what？发现go语言的都没有。翻了好几页，特么也没有。 进阶程序员 config language:go 筛选编程语言，这样基本可以找到一些热门，关键词准确的项目。 高级程序员 config language:go stars:\u003e1000 forks:\u003e100 pushed:\u003e2020-05-01 查找并伴随着一些标签信息。之前文章已经介绍过了。 stars：点赞人数，可以看出项目好坏的主要指标。 forks：项目的forks人数，基本可以看出来项目的维护人数，也是越多越好。 pushed：上次合并代码的时间，可以判断出项目是否很久没有人维护了。 其他还有很多标签，具体可以参考官方文档。 ","date":"2020-12-12","objectID":"/02-github-search/:2:1","tags":["tools"],"title":"【tools】如何在Github找到你想要的项目？","uri":"/02-github-search/"},{"categories":["tools"],"content":"总结 使用相关的参数，获取到精准的您所需要项目。快去试试吧。 后续会出一个如何获取您的语言近期热门的项目。 ","date":"2020-12-12","objectID":"/02-github-search/:3:0","tags":["tools"],"title":"【tools】如何在Github找到你想要的项目？","uri":"/02-github-search/"},{"categories":["go"],"content":"简单的介绍一个Go语言必须的库，强大的命令行工具.","date":"2020-12-12","objectID":"/06-github-cobra/","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"简单的介绍一个Go语言必须的库，强大的命令行工具. ","date":"2020-12-12","objectID":"/06-github-cobra/:0:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"简介 扩展使用cobra库的，简单的命令行参数配置。 预运行和后运行的回调函数的注册使用。 ","date":"2020-12-12","objectID":"/06-github-cobra/:1:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"开始 ","date":"2020-12-12","objectID":"/06-github-cobra/:2:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"运行函数的介绍 在运行命令的主函数之前或之后可以运行的函数。 主要有一下几个运行函数，按从上往下先后的顺序调用： PersistentPreRun PreRun Run PostRun PersistentPostRun 之前主要使用的demo只使用到Run的函数，其实实际的cli运行当中，PreRun函数也是常被用到做一些资源的初始化。 ","date":"2020-12-12","objectID":"/06-github-cobra/:2:1","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"怎么给命令行设置参数 本地标志:本地分配标志，该标志将仅适用于该特定命令。 localCmd.Flags().StringVarP(\u0026Source, \"source\", \"s\", \"\", \"Source directory to read from\") 持久标志:标志可以是\"持久\"的，这意味着此标志将可用于分配给它的命令以及该命令下的每个命令。对于全局标志，将标志作为根上的持久标志分配。 rootCmd.PersistentFlags().BoolVarP(\u0026Verbose, \"verbose\", \"v\", false, \"verbose output\") ","date":"2020-12-12","objectID":"/06-github-cobra/:2:2","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"实际demo测试 以之前获取版本号为例： 测试运行参数 // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"A brief description of version\", Long: `A longer description of version long`, PreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\"version PreRun\") }, Run: func(cmd *cobra.Command, args []string) { flags, _ := cmd.Flags().GetBool(\"flags\") fmt.Println(\"flags =\", flags) fmt.Println(\"version main called\") }, PostRun: func(cmd *cobra.Command, args []string) { fmt.Println(\"version PostRun\") }, } 测试flags标志位： func init() { rootCmd.AddCommand(versionCmd) versionCmd.Flags().BoolP(\"flags\", \"t\", false, \"test flags\") } 测试结果 $ go run main.go version -t version PreRun flags = true version main called version PostRun $ go run main.go version version PreRun flags = false version main called version PostRun ","date":"2020-12-12","objectID":"/06-github-cobra/:3:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"总结 基本的使用扩展就到这边了，基本可以实现一个满足你的基础使用框架。 最后还有一个缺点是命令行工具不可以tab补全，官方也有实现方法使用，bash的方式。大家也可以去学习一下。后面有时间也会考虑一下出一个文档。 ","date":"2020-12-12","objectID":"/06-github-cobra/:4:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【2】","uri":"/06-github-cobra/"},{"categories":["go"],"content":"简单的介绍一个Go语言必须的库，强大的命令行工具.","date":"2020-12-12","objectID":"/05-github-cobra/","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"简单的介绍一个Go语言必须的库，强大的命令行工具. ","date":"2020-12-12","objectID":"/05-github-cobra/:0:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"简介 Cobra既是一个用于创建功能强大的现代CLI应用程序的库，也是一个生成应用程序和命令文件的程序。 Cobra被用于许多Go项目中，比如Kubernetes、Hugo和githubcli等等。 github地址: cobra ","date":"2020-12-12","objectID":"/05-github-cobra/:1:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"准备工作 ","date":"2020-12-12","objectID":"/05-github-cobra/:2:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"安装 go get -u github.com/spf13/cobra 然后在你的项目引入Cobra的包: import \"github.com/spf13/cobra\" go get后，也会给系统安一个cobra的工具，我们可以使用这个工具生成项目的demo。 ","date":"2020-12-12","objectID":"/05-github-cobra/:2:1","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"工具常用命令 $ cobra -h Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: cobra [command] Available Commands: add Add a command to a Cobra Application help Help about any command init Initialize a Cobra Application Flags: -a, --author string author name for copyright attribution (default \"YOUR NAME\") --config string config file (default is $HOME/.cobra.yaml) -h, --help help for cobra -l, --license string name of license for the project --viper use Viper for configuration (default true) Use \"cobra [command] --help\" for more information about a command. ","date":"2020-12-12","objectID":"/05-github-cobra/:3:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"基础实践 ","date":"2020-12-12","objectID":"/05-github-cobra/:4:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"demo工程项目生成 建议cobra空文件夹 使用go mod初始化文件 go mod init cobra 使用cobra工具生成项目文件: cobra init --pkg-name cobra --author coolliuzw 运行测试 $ go run main.go A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. 步骤执行完成后，就有一个基本可运行的命令行demo。 ","date":"2020-12-12","objectID":"/05-github-cobra/:4:1","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"demo程序修改 go run main.go，demo输出的是以上的内容，那么我们应该如何去修改他呢？跟我来： vim cmd/root.go 就能看到输出的这段代码了。cobra自动生成命令行都放置在cmd这个目录下。 // rootCmd represents the base command when called without any subcommands var rootCmd = \u0026cobra.Command{ Use: \"cobra\", Short: \"A brief description of your application\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, // Uncomment the following line if your bare application // has an action associated with it: // Run: func(cmd *cobra.Command, args []string) { }, } demo也有一些注释说明简单的用法，我们来修改一下demo在测试一下。 修改 // rootCmd represents the base command when called without any subcommands var rootCmd = \u0026cobra.Command{ Use: \"cobra\", Short: \"A brief description of coolliuzw\", Long: `A longer description of coolliuzw blog`, // Uncomment the following line if your bare application // has an action associated with it: // Run: func(cmd *cobra.Command, args []string) { }, } 运行 go run main.go A longer description of coolliuzw blog 具体修改了什么看一下代码的注释。 ","date":"2020-12-12","objectID":"/05-github-cobra/:4:2","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"添加自定义Cli命令 添加version命令行工具. cobra add version --author coolliuzw cmd目录下多了一个version.go的文件。 尝试修改version测试 // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"A brief description of version\", Long: `A longer description of version long`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version called\") }, } 查看是否添加成功 go run main.go help A longer description of coolliuzw blog Usage: cobra [command] Available Commands: help Help about any command version A brief description of version Flags: --config string config file (default is $HOME/.cobra.yaml) -h, --help help for cobra -t, --toggle Help message for toggle Use \"cobra [command] --help\" for more information about a command. //go run main.go help可以看程序支持的命令行. //version A brief description of version也添加进去了 测试调用. $ go run main.go version version called // 成功调用 ","date":"2020-12-12","objectID":"/05-github-cobra/:4:3","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"总结 这边只说说demo怎么构建起来，是不是很简单。去创建你的cli工具吧 ","date":"2020-12-12","objectID":"/05-github-cobra/:5:0","tags":["go"],"title":"【Go】Cobra Go最强大的命令行工具【1】","uri":"/05-github-cobra/"},{"categories":["go"],"content":"介绍一个Go程序员不理解for...range容易出现的错误.","date":"2020-12-12","objectID":"/04-for...range/","tags":["go"],"title":"【Go】for ... range 的坑，你踩了吗？","uri":"/04-for...range/"},{"categories":["go"],"content":"介绍一个Go程序员不理解for…range容易出现的错误. ","date":"2020-12-12","objectID":"/04-for...range/:0:0","tags":["go"],"title":"【Go】for ... range 的坑，你踩了吗？","uri":"/04-for...range/"},{"categories":["go"],"content":"简述 for...range是Go编程里面非常常用到的Slice和map的遍历方式，它的伪代码你懂吗？ 常常有人被踩到循环赋值，指针引用的坑的问题。 ","date":"2020-12-12","objectID":"/04-for...range/:1:0","tags":["go"],"title":"【Go】for ... range 的坑，你踩了吗？","uri":"/04-for...range/"},{"categories":["go"],"content":"for…range遍历取值 package main import \"fmt\" type Person struct { name string } func main() { personSlice := []Person{ {\"shazi\"}, {\"coolliuzw\"}, } var res []*Person for _, person := range personSlice { res = append(res, \u0026person) } for _, person := range res { fmt.Println(\"name--\u003e\u003e:\", person.name) } } 输出结果： name--\u003e\u003e: coolliuzw name--\u003e\u003e: coolliuzw 是不是和你的预期不太一样，为什么是这样的呢？ for range 的时候，person 只初始化了一次，理解这句话应该就知道为什么了。 之后的遍历都是在原来遍历的基础上赋值，所有person的指针（地址）并没有变。该指针指向的是最后一次遍历的person的值，所以最后结果集中，也就都成了最后遍历的v的值 最后提一个问题？刚刚出现的问题怎么解决呢？ 方法一 for i := range personSlice { res = append(res, \u0026personSlice[i]) 方法二 // 哈哈，也可以考虑一下为什么这么定义person不会重复定义哦 for _, person := range personSlice { person := person res = append(res, \u0026person) } ","date":"2020-12-12","objectID":"/04-for...range/:2:0","tags":["go"],"title":"【Go】for ... range 的坑，你踩了吗？","uri":"/04-for...range/"},{"categories":["go"],"content":"总结 指针是Go、C、C++的重点支持，使用好指针对内存，GC、性能都有很大的提高。一定要理解清楚哦。 ","date":"2020-12-12","objectID":"/04-for...range/:3:0","tags":["go"],"title":"【Go】for ... range 的坑，你踩了吗？","uri":"/04-for...range/"},{"categories":["编程"],"content":"聊聊无处不在的HTTP演进史.","date":"2020-12-11","objectID":"/01-http-study/","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"聊聊无处不在的HTTP演进史. ","date":"2020-12-11","objectID":"/01-http-study/:0:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"简述 HTTP，日常无论是开发还是生活中的浏览网页，可以说只要有联网基本就能接触到HTTP。今天来聊聊HTTP的演进史，HTTP1.0，HTTP1.1，HTTP2.0。 超文本传输协议（HTTP）全名(hypertext transport protocol ：基本50%程序员都不知道，如果你知道你就比50%程序员优秀啦) 是用于传输诸如HTML的超媒体文档的应用层协议。 设计之初用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。eg: 服务之间内部的请求。 HTTP是无状态协议，这也是被大量应用主要的原因，有着很多好处，不过也有一定的缺点，比如：cookie/session 解决无状态的一种方法。尽管底层的TCP/IP层是有状态的，但是分层可以说，已经把它们完全隔离开。 ","date":"2020-12-11","objectID":"/01-http-study/:1:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"HTTP1.0 HTTP1.0时代，诞生时间，我出身的时候，1996年，基本弃用了。 影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟 带宽 延迟： 浏览器阻塞（HOL blocking） DNS 查询（DNS Lookup） 建立连接（Initial connection）：默认是使用短连接的方式. ","date":"2020-12-11","objectID":"/01-http-study/:2:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"HTTP1.1 HTTP1.1时代，1999年，目前还是被大量的使用，HTTP1.1也是当前使用最为广泛的HTTP协议。近几年开始慢慢的有些大企业使用HTTP2的方式接入服务了。 区别: 缓存处理 带宽优化及网络连接的使用 错误通知的管理 ：新添加了24个错误原因码 Host头处理 长连接：核心改变，默认长连接的方式。如果特殊场景需要使用短连接的方式需要带上 Connection： close头域。 扩展一个问题, HTTP1.1使用长连接的方式，是否需要或者说必要带,Connection： keep-alive? 这个我也查阅了 RFC文档，没有提到，需要带上，所以说默认没带的情况，服务端需要人为是长连接。 go语言的net包、httpclient也是默认使用长连接的方式，官方是没有携带 keep-alive头域的。 ","date":"2020-12-11","objectID":"/01-http-study/:3:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"HTTPS HTTP和HTTPS对比，简单的说一下。 HTTPS是基于TLS之上，加密传输。 HTTP是基于TCP之上，非加密传输。 简单的说: 抓包HTTP可以抓到。 HTTP少了加密的过程，性能估计更强。 HTTPS使用加密协议，安全性更强。 具体其他想了解可以Google看看。 ","date":"2020-12-11","objectID":"/01-http-study/:4:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"HTTP2 ","date":"2020-12-11","objectID":"/01-http-study/:5:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"http2 新特性 ​ ● 新的二进制格式（Binary Format）：HTTP1.x的解析是基于文本。HTTP2.0的协议解析决定采用二进制格式。 多路复用（MultiPlexing）:共享连接，应该是解决HTTP1.x中队头堵塞的问题。 HTTP2image \" HTTP2 ● header压缩 ● 服务端推送（server push） ","date":"2020-12-11","objectID":"/01-http-study/:5:1","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"HTTP3 目前基本没有使用，先不说。 ","date":"2020-12-11","objectID":"/01-http-study/:6:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["编程"],"content":"总结 最近在项目，想对HTTP1.1和HTTP2.0做性能分析，学习相关基础知识对后续分析有一定帮助，后续也会出一个 Go HTTP1.1和HTTP2.0性能分析文档。 ","date":"2020-12-11","objectID":"/01-http-study/:7:0","tags":["编程"],"title":"【http】聊聊无处不在的HTTP演进史","uri":"/01-http-study/"},{"categories":["go"],"content":"介绍Go语言使用的开发工具，以mac为例，window同.","date":"2020-12-10","objectID":"/03-dev-tools/","tags":["go"],"title":"【Go】开发和编译环境的基础安装【2】","uri":"/03-dev-tools/"},{"categories":["go"],"content":"介绍Go语言使用的开发工具，以mac为例，window同. ","date":"2020-12-10","objectID":"/03-dev-tools/:0:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【2】","uri":"/03-dev-tools/"},{"categories":["go"],"content":"简述 ​ 介绍Go的开发工具： atom + go plus vscode + go + Code Runner + Gopls Goland (收费) ","date":"2020-12-10","objectID":"/03-dev-tools/:1:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【2】","uri":"/03-dev-tools/"},{"categories":["go"],"content":"atom + go plus 未使用过，之前文章有看到有大佬用过，感觉也不错 ","date":"2020-12-10","objectID":"/03-dev-tools/:2:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【2】","uri":"/03-dev-tools/"},{"categories":["go"],"content":"vscode + go + Code Runner + Gopls 免费里面最好用的vscode + go插件 记得一定要使用 Go 官方开发的 gopls 功能，使用体验巨大提升。 go tools工具安装，安装前需要配置 GoProxy，建议使用七牛云。不配置GoProxy多半go tools是安装失败的 使用Code Runner运行代码 ","date":"2020-12-10","objectID":"/03-dev-tools/:3:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【2】","uri":"/03-dev-tools/"},{"categories":["go"],"content":"goland 安装 Go官网下载安装，收费软件也是里面功能最强的软件，比较吃电脑的性能。需要较大的内存。 学生记得去申请免费使用的License. ","date":"2020-12-10","objectID":"/03-dev-tools/:4:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【2】","uri":"/03-dev-tools/"},{"categories":["go"],"content":"总结 简单介绍可以开发的工具，具体安装使用教程参考Google或者Baidu其他一些文章，这边只是给一个开发工具初步的建议。推荐有条件的开发者使用Goland，基础的学习者，使用Vscode就足够了。 ","date":"2020-12-10","objectID":"/03-dev-tools/:5:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【2】","uri":"/03-dev-tools/"},{"categories":["go"],"content":"一个用Go编译的go语言交叉编译工具.","date":"2020-12-09","objectID":"/02-cross-compiler/","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"一个用Go编译的go语言交叉编译工具. ","date":"2020-12-09","objectID":"/02-cross-compiler/:0:0","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"简述 ​ 程序编译是编译型语言，运行必备的过程。Go的重要的特性之一就是有着优秀的编译速度，和之前编写C相比，有着非常明显的提升。有人开玩笑说，Go语言是作者在编译C++过程中开发。 ​ 当然编译速度快的情况下，实现交叉编译也尤其的简单，只需要做环境变量上的修改。 ","date":"2020-12-09","objectID":"/02-cross-compiler/:1:0","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"需求 ​ Gopher一般开发调试环境是Window 和 Mac 环境，但是项目测试往往需要跑到linux服务器上测试。这时候就需要编译Linux的可运行程序。最基础的方式就是代码下载到Linux上编译，获得需要的运行程序。过程中就有了需要Linux下载代码的一个过程。(支持CI可以忽略) 最简单的方式，我认为是window上直接可编译Linux可运行文件，使用ssh工具的lrzsz工具，直接拖到Linux运行代码。下面简单的介绍一下我实现的工具。 ","date":"2020-12-09","objectID":"/02-cross-compiler/:2:0","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"原理 参考相关文档： 在powershell命令行中编译（示例编译64位linux程序） $env:GOOS=\"linux\" $env:GOARCH=\"amd64\" go build xxx.go 在CMD命令行中编译（示例编译64位linux程序） set GOARCH=amd64 set GOOS=linux go build -a 这也是我们代码实现的原理基础。 ","date":"2020-12-09","objectID":"/02-cross-compiler/:3:0","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"实现 直接修改环境变量 不可行，想编译window还得手动改回去。 bat脚本，有兴趣可以自己学习一下。 缺点，只能用于window，不能通用化。 使用麻烦，需要需要修改环境变量和解除环境变量 ","date":"2020-12-09","objectID":"/02-cross-compiler/:4:0","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"Go编译的cli运行工具 既然大家是学习Go的那么就用Go实现一个可以支持交叉编译的工具 直接上代码，基于之前说的原理: package main import ( \"flag\" \"fmt\" \"os\" \"os/exec\" ) var buildPath = flag.String(\"p\", \"./\", \"input build path string\") var makeFileName = flag.String(\"o\", \"\", \"output file name config\") func main() { flag.Parse() _ = os.Setenv(\"CGO_ENABLED\", \"0\") _ = os.Setenv(\"GOARCH\", \"amd64\") _ = os.Setenv(\"GOOS\", \"linux\") arg := []string{\"build\"} if len(*makeFileName) \u003e 0 { arg = append(arg, []string{\"-o\", *makeFileName}...) } arg = append(arg, *buildPath) if err := exec.Command(\"go\", arg...).Run(); err != nil { fmt.Println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!make Failed!!!!!!!!!!!!!!!!!!!!!!!!!!\", err) } else { fmt.Println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!make SUCCESS!!!!!!!!!!!!!!!!!!!!!!!!!!\") } } 代码就是基于原理开发的。在所在的平台执行命令，以mac为例。 编译工具（一次编译永久使用） go build -o gomake 试用工具交叉编译 gomoke -o linux_go # liuzhiwei @ liuzhiweideMacBook-Pro in ~/code/go/mgo/test [23:45:33] C:127 $ ls go.mod gomake main.go # liuzhiwei @ liuzhiweideMacBook-Pro in ~/code/go/mgo/test [23:45:35] $ ./gomake -o linux_go !!!!!!!!!!!!!!!!!!!!!!!!!!make SUCCESS!!!!!!!!!!!!!!!!!!!!!!!!!! # liuzhiwei @ liuzhiweideMacBook-Pro in ~/code/go/mgo/test [23:46:06] $ ls go.mod gomake linux_go main.go 使用以上过程实现的编译linux运行程序，这边是用Mac测试，window同原理。 常用方式：gomake编译工具移动到需要编译的目录运行 ./gomake即可。 ","date":"2020-12-09","objectID":"/02-cross-compiler/:4:1","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"总结 ​ 主要介绍Go编写的Go语言交叉编译工具，实现Window和Mac编译Linux可运行程序。可以试用起来，这个有打打的提高了我的工作效率。 ","date":"2020-12-09","objectID":"/02-cross-compiler/:5:0","tags":["go"],"title":"【Go】window和Mac交叉编译Linux实战和源码分享","uri":"/02-cross-compiler/"},{"categories":["go"],"content":"一个介绍go语言相关开发环境安装软件.","date":"2020-12-08","objectID":"/01-env-install/","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"go语言编译环境安装的简单介绍. ","date":"2020-12-08","objectID":"/01-env-install/:0:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"简述 学习一门新的语言，安装一个可以运行调试的环境尤为重要。 Go语言是可跨平台的语言，支持常见的开发环境 Linux Mac OS X Windows ","date":"2020-12-08","objectID":"/01-env-install/:1:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"开始 ","date":"2020-12-08","objectID":"/01-env-install/:2:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"Go语言官网 https://golang.org，一般的情况是无法打开使用的，但是go官方有一个中文镜像的官网 https://golang.google.cn，大家可以使用这个网址下载。 安装包下载建议，一般使用官方最新的release版本即可。 点击download进行选着相应的系统版本安装。 ","date":"2020-12-08","objectID":"/01-env-install/:2:1","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"Linux If you have a previous version of Go installed, be sure to remove it before installing another. Download the archive and extract it into /usr/local, creating a Go tree in /usr/local/go. For example, run the following as root or through sudo: tar -C /usr/local -xzf go1.14.3.linux-amd64.tar.gz Add /usr/local/go/bin to the PATH environment variable. You can do this by adding the following line to your $HOME/.profile or /etc/profile (for a system-wide installation): export PATH=$PATH:/usr/local/go/bin Note: Changes made to a profile file may not apply until the next time you log into your computer. To apply the changes immediately, just run the shell commands directly or execute them from the profile using a command such as source $HOME/.profile. Verify that you’ve installed Go by opening a command prompt and typing the following command: $ go version Confirm that the command prints the installed version of Go. ","date":"2020-12-08","objectID":"/01-env-install/:3:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"基础安装实战 建议使用wget下载到linux的临时目录中. eg: wget https://dl.google.com/go/go1.14.4.linux-amd64.tar.gz tar -C /usr/local -xzf {name} Eg: tar -C /usr/local -xzf go1.14.4.linux-amd64.tar.gz 修改环境变量 vi /etc/profile 打开 /etc/profile，尾行添加: - PATH=$PATH:/usr/local/go/bin 保存退出 source /etc/profile 查看版本号，验证是否生效。 - go version ","date":"2020-12-08","objectID":"/01-env-install/:3:1","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"Window Open the MSI file you downloaded and follow the prompts to install Go. By default, the installer will install Go to C:\\Go. You can change the location as needed. After installing, you will need to close and reopen any open command prompts so that changes to the environment made by the installer are reflected at the command prompt. Verify that you’ve installed Go. In Windows, click the Start menu. In the menu’s search box, type cmd, then press the Enter key. In the Command Prompt window that appears, type the following command: $ go version Confirm that the command prints the installed version of Go. ","date":"2020-12-08","objectID":"/01-env-install/:4:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"Mac Open the package file you downloaded and follow the prompts to install Go. The package installs the Go distribution to /usr/local/go. The package should put the /usr/local/go/bin directory in your PATH environment variable. You may need to restart any open Terminal sessions for the change to take effect. Verify that you’ve installed Go by opening a command prompt and typing the following command: $ go version Confirm that the command prints the installed version of Go. ","date":"2020-12-08","objectID":"/01-env-install/:5:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["go"],"content":"总结 ​ 主要介绍，Go包的安装，下一篇介绍各个平台使用的开发工具。 ","date":"2020-12-08","objectID":"/01-env-install/:6:0","tags":["go"],"title":"【Go】开发和编译环境的基础安装【1】","uri":"/01-env-install/"},{"categories":["c语言"],"content":"一个简单的，跨平台c环境变量获取库.","date":"2020-12-08","objectID":"/01-get-env/","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"一个简单的，跨平台c环境变量获取库. ","date":"2020-12-08","objectID":"/01-get-env/:0:0","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"简述 c语言获取环境的变量的方式，window和linux都是相同的方式，通常使用getenv接口进行获取环境变量，但是往往我们获取环境变量的时候，常需要做一定的判断: 环境变量未获取到，提示错误（assert），终止程序运行。 环境变量未获取到，使用自定义默认值，初始化环境变量。 bool类型环境变量设置为 yes，true，y，t 等等，能直接转换为bool类型 ","date":"2020-12-08","objectID":"/01-get-env/:1:0","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"源代码 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cassert.h\u003e#include \u003cstring.h\u003e typedef enum { ENV_FALSE = 0, ENV_TRUE = 1 } env_bool_t; #ifdef _WIN32 #define strcasecmp(s1, s2) stricmp(s1, s2) #endif static env_bool_t zstr(const char *s) { return (s == NULL || s[0] == '\\0') ? ENV_TRUE : ENV_FALSE; } static const char* env_get_string_imp(const char* key, const char* default_value, env_bool_t must_get) { char* val = getenv(key); if (!zstr(val)) { return val; } if (must_get) { printf(\"env key \\\"%s\\\"does not find!\\n\", key); assert(NULL); } else { return default_value; } } static const int env_get_int_imp(const char* key, const int default_value, env_bool_t must_get) { const char* val = getenv(key); if (!zstr(val)) { return atoi(val); } if (must_get) { printf(\"env key \\\"%s\\\"does not find!\\n\", key); assert(NULL); } else { return default_value; } } static env_bool_t env_true(const char *s) { if (zstr(s)) { return ENV_FALSE; } if (!strcasecmp(s, \"yes\") || !strcasecmp(s, \"true\") || !strcasecmp(s, \"y\") || !strcasecmp(s, \"t\") || !strcasecmp(s, \"1\") || !strcasecmp(s, \"enabled\") || !strcasecmp(s, \"active\") || !strcasecmp(s, \"allow\") || !strcasecmp(s, \"on\")) { return ENV_TRUE; } return ENV_FALSE; } static const env_bool_t env_get_bool_imp(const char* key, const env_bool_t default_value, env_bool_t must_get) { const char* val = getenv(key); if (!zstr(val)) { return env_true(val); } if (must_get) { printf(\"env key \\\"%s\\\"does not find!\\n\", key); assert(NULL); } else { return default_value; } } const char* env_get_string(const char* key, const char* default_value) { return env_get_string_imp(key, default_value, ENV_FALSE); } const int env_get_int(const char* key, const int default_value) { return env_get_int_imp(key, default_value, ENV_FALSE); } const env_bool_t env_get_bool(const char* key, const env_bool_t default_value) { return env_get_bool_imp(key, default_value, ENV_FALSE); } const char* env_mustget_string(const char* key) { return env_get_string_imp(key, NULL, ENV_TRUE); } const int env_mustget_int(const char* key) { return env_get_int_imp(key, 0, ENV_TRUE); } const env_bool_t env_mustget_bool(const char* key) { return env_get_bool_imp(key, ENV_FALSE, ENV_TRUE); } ","date":"2020-12-08","objectID":"/01-get-env/:2:0","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"关键接口说明 ","date":"2020-12-08","objectID":"/01-get-env/:3:0","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"自定义默认值获取接口 const char* env_get_string(const char* key, const char* default_value) ","date":"2020-12-08","objectID":"/01-get-env/:3:1","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"获取失败assert接口 const char* env_mustget_string(const char* key) ","date":"2020-12-08","objectID":"/01-get-env/:3:2","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"获取bool类型接口 const env_bool_t env_mustget_bool(const char* key) ","date":"2020-12-08","objectID":"/01-get-env/:3:3","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["c语言"],"content":"Github地址 https://github.com/CoolLiuzw/c-env ","date":"2020-12-08","objectID":"/01-get-env/:4:0","tags":["c语言"],"title":"【c】跨平台c系统环境变量获取库","uri":"/01-get-env/"},{"categories":["tools"],"content":"github相关的命令.","date":"2020-12-06","objectID":"/01-github-search/","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["tools"],"content":"github常用的搜索方式. ","date":"2020-12-06","objectID":"/01-github-search/:0:0","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["tools"],"content":"1. 最常用的Git命令 克隆代码 git clone http地址 git地址 拉取代吗 git pull 切换分支 git checkout \u003cbranch_name\u003e 查看工作区状态 git status 查看过往提交记录 git log 提交到暂存区 git add 提交到本地仓库 git commit -m \"提交注释\" 提交到远程仓库 git pull ","date":"2020-12-06","objectID":"/01-github-search/:1:0","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["tools"],"content":"2. GitHub介绍和搜索项目 按项目名称（name）查找 in:name dev-tester 按项目描述（description）查找 in:description 微服务 in:about 微服务 按README描述查找 in:readme 微服务相关 设置星星数（stars）查询范围 stars:\u003e1000 设置fork数（forks）查询范围 forks:\u003e500 按项目语言筛选 language:java 按项目作者查找 user:CoolLiuzw 按项目大小查找 size:\u003e=500 更新时间 pushed:\u003e2020-01-01 组合查找 in:name dev-tester in:description 微服务 stars:\u003e1000 ","date":"2020-12-06","objectID":"/01-github-search/:2:0","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["tools"],"content":"常用查找示例: in:about gin language:go ","date":"2020-12-06","objectID":"/01-github-search/:2:1","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["tools"],"content":"3. Github下载加速 绑定hosts linux/window尝试通过绑定hosts的方式获取一定的加速，不过本地测试加速的效果不明显，还是建议大家借助Gitee的方式，实现快速的下载代码。 借助Gitee下载代码 Gitee对于github上比较出名的项目也有一定的维护，基本上能做到每天同步更新一次的频率，可以查找一下对应的项目。 使用油猴插件gitfast ","date":"2020-12-06","objectID":"/01-github-search/:3:0","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["tools"],"content":"4. GitHub项目创建及上传 待补充 ","date":"2020-12-06","objectID":"/01-github-search/:4:0","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["tools"],"content":"总结 其实，如何玩转github的相关知识很多开发的小伙伴还是没有认真的学习过，建议通过本文的学习，你能通过github上找到自己想要的开源项目。 ","date":"2020-12-06","objectID":"/01-github-search/:5:0","tags":["tools"],"title":"【tools】 如何玩转GitHub？","uri":"/01-github-search/"},{"categories":["blog"],"content":"测试新的blog主题.","date":"2020-12-06","objectID":"/02-blog-about/","tags":["blog"],"title":"【blog】关于本博客","uri":"/02-blog-about/"},{"categories":["blog"],"content":"测试新的blog主题，测试搜索。 更新一些最近学习说明到的写博客的简单作用。 ","date":"2020-12-06","objectID":"/02-blog-about/:0:0","tags":["blog"],"title":"【blog】关于本博客","uri":"/02-blog-about/"},{"categories":["blog"],"content":"博客 英文名称 blog ，正式名称为网络日记 ","date":"2020-12-06","objectID":"/02-blog-about/:1:0","tags":["blog"],"title":"【blog】关于本博客","uri":"/02-blog-about/"},{"categories":["blog"],"content":"为什么要写博客？ 需要总结和思考。有时候我们一直在赶路，却忘了放慢脚步 提升文笔组织能力 提升学习总结能力 提升逻辑思维能力 帮助他人，结交朋友 ","date":"2020-12-06","objectID":"/02-blog-about/:2:0","tags":["blog"],"title":"【blog】关于本博客","uri":"/02-blog-about/"},{"categories":["blog"],"content":"写博客的建议 计算机相关专业的同学尽量在大学时期，养成良好的写博客的习惯，工作的时候发现没什么时间写博客。 冰冻三尺非一日之寒，写博客也是，短期内可能看不到效果，但是长期坚持，对自己的提升很有帮助。 ","date":"2020-12-06","objectID":"/02-blog-about/:3:0","tags":["blog"],"title":"【blog】关于本博客","uri":"/02-blog-about/"},{"categories":["blog"],"content":"注册博客 博客园 CSDN 简书 知乎 … 购买服务器搭建个人博客 使用github pages或者gitee pages搭建 ","date":"2020-12-06","objectID":"/02-blog-about/:4:0","tags":["blog"],"title":"【blog】关于本博客","uri":"/02-blog-about/"}]